; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\BootLoad\Intel\Idt.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_master
PUBLIC	_except
PUBLIC	_slave
PUBLIC	_fixup
EXTRN	_stosb:PROC
EXTRN	_lidt:PROC
_fixup	DB	'mmmmmmmmxmxxxxxmmxmmmmmmmmmmmmmmmmmmmmmmssssssssmmmmmmmm'
	DB	'mmmmmmmm', 00H
_master	DB	0faH, 090H, '`', 01eH, 0fH, ' ', 0daH, 'Rj', 010H, 01fH, 0baH
	DB	00H, ' ', 00H, 00H, 0fH, '"', 0daH, 'Tjx', 0ffH, 015H, 'xxxx', 094H
	DB	0b0H, ' ', 0e6H, ' X', 0fH, '"', 0d8H, 01fH, 'a', 0cfH, 'xxxxx'
	DB	'xxxxxxxxxxxxxxxxxxx'
_except	DB	0faH, 090H, '`', 01eH, 0fH, ' ', 0daH, 'Rj', 010H, 01fH, 0baH
	DB	00H, ' ', 00H, 00H, 0fH, '"', 0daH, 'T', 0ffH, 't$,', 0ffH, 015H
	DB	'xxxx', 094H, 0b0H, ' ', 0e6H, ' X', 0fH, '"', 0d8H, 01fH, 'a', 08fH
	DB	04H, '$', 0cfH, 'xxxxxxxxxxxxxxxxxxx'
_slave	DB	0faH, 090H, '`', 01eH, 0fH, ' ', 0daH, 'Rj', 010H, 01fH, 0baH
	DB	00H, ' ', 00H, 00H, 0fH, '"', 0daH, 'Tjx', 0ffH, 015H, 'xxxx', 094H
	DB	0b0H, ' ', 0e6H, 0a0H, 0e6H, ' X', 0fH, '"', 0d8H, 01fH, 'a', 0cfH
	DB	'xxxxxxxxxxxxxxxxxxxxxx'
PUBLIC	_DefaultIsrStub
PUBLIC	_InstallIsr
PUBLIC	_InstallIdt
PUBLIC	_EnableIdt
PUBLIC	_InstallIrq
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\intel\idt.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallIrq PROC

; 39   : bool InstallIrq(u8 *base, u32 size) {

	push	edi

; 40   :     u32 *irq = (u32*)base;
; 41   :     for (int i = 0; i < 256; i++) {
; 42   :         irq[i] = (u32)DefaultIsrStub;

	mov	edi, DWORD PTR _base$[esp]
	mov	eax, OFFSET _DefaultIsrStub
	mov	ecx, 256				; 00000100H
	rep stosd

; 43   :     }
; 44   :     return true;

	xor	eax, eax
	inc	eax
	pop	edi

; 45   : }

	ret	0
_InstallIrq ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\intel\idt.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_EnableIdt PROC

; 85   :     u32 *idtr = (u32*)&base[256*8+2];

	mov	eax, DWORD PTR _base$[esp-4]
	add	eax, 2050				; 00000802H

; 86   :     lidt(idtr);

	push	eax
	call	_lidt

; 87   :     return true;

	xor	eax, eax
	pop	ecx
	inc	eax

; 88   : }

	ret	0
_EnableIdt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\intel\idt.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallIdt PROC

; 67   :     u64 *idt = (u64*)base;
; 68   :     u8 *isr = Monitor->GetBase('ISR ');

	mov	eax, DWORD PTR _Monitor
	push	esi
	push	edi
	push	1230197280				; 49535220H
	call	DWORD PTR [eax+24]
	mov	esi, DWORD PTR _base$[esp+8]
	mov	edi, eax
	pop	ecx

; 69   :     for (int i = 0; i < 256; i++) {

	xor	edx, edx
$LL4@InstallIdt:

; 70   :         idt[i] = 0x8E0000080000 + (u32)&isr[i*64];

	xor	eax, eax
	mov	ecx, edi
	add	ecx, 524288				; 00080000H
	mov	DWORD PTR [esi+edx*8], ecx
	adc	eax, 36352				; 00008e00H
	mov	DWORD PTR [esi+edx*8+4], eax

; 71   :         if (i >= 128) idt[i] |= (u64)3 << 45;

	cmp	edx, 128				; 00000080H
	jl	SHORT $LN3@InstallIdt
	or	DWORD PTR [esi+edx*8+4], 24576		; 00006000H
	mov	eax, ecx
	mov	DWORD PTR [esi+edx*8], eax
$LN3@InstallIdt:

; 69   :     for (int i = 0; i < 256; i++) {

	inc	edx
	add	edi, 64					; 00000040H
	cmp	edx, 256				; 00000100H
	jl	SHORT $LL4@InstallIdt

; 72   :     }
; 73   : 
; 74   :     u32 *idtr = (u32*)&base[256*8];
; 75   :     idtr[0] = (256*8 - 1) << 16;

	mov	DWORD PTR [esi+2048], 134152192		; 07ff0000H

; 76   :     idtr[1] = (u32)base;
; 77   : 
; 78   :     u32 *ivtr = (u32*)&base[256*8 + 16];
; 79   :     ivtr[0] = 0x3FF << 16;
; 80   :     ivtr[1] = 0x00000000;
; 81   :     return true;

	xor	eax, eax
	mov	DWORD PTR [esi+2052], esi
	inc	eax
	and	DWORD PTR [esi+2068], 0
	pop	edi
	mov	DWORD PTR [esi+2064], 67043328		; 03ff0000H
	pop	esi

; 82   : }

	ret	0
_InstallIdt ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\intel\idt.c
_TEXT	SEGMENT
_irq$1$ = -4						; size = 4
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallIsr PROC

; 47   : bool InstallIsr(u8 *base, u32 size) {

	push	ecx

; 48   :     u32 *irq = (u32*)Monitor->GetBase('IRQ ');

	mov	eax, DWORD PTR _Monitor
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	1230131488				; 49525120H
	call	DWORD PTR [eax+24]
	mov	esi, DWORD PTR _base$[esp+20]

; 49   :     for (int i = 0; i < 256; i++) {

	xor	edi, edi
	pop	ecx
	mov	DWORD PTR _irq$1$[esp+20], eax
	mov	ebp, edi
$LL8@InstallIsr:

; 50   :         char *isr = &base[i*64];
; 51   :         stosb(isr, i, 64);

	push	64					; 00000040H
	push	edi
	push	esi
	call	_stosb
	add	esp, 12					; 0000000cH

; 52   : 
; 53   :         u8 d = fixup[MIN(i, elementsof(fixup)-2)];

	cmp	edi, 63					; 0000003fH
	jae	SHORT $LN11@InstallIsr
	mov	eax, edi
	jmp	SHORT $LN12@InstallIsr
$LN11@InstallIsr:
	push	63					; 0000003fH
	pop	eax
$LN12@InstallIsr:
	mov	bl, BYTE PTR _fixup[eax]

; 54   :         switch (d) {

	cmp	bl, 109					; 0000006dH
	je	SHORT $LN3@InstallIsr
	cmp	bl, 115					; 00000073H
	je	SHORT $LN2@InstallIsr
	cmp	bl, 120					; 00000078H
	jne	SHORT $LN4@InstallIsr

; 57   :         case 'x': movsd(isr, except, 0x40/4); break;

	push	16					; 00000010H
	push	OFFSET _except
	jmp	SHORT $LN17@InstallIsr
$LN2@InstallIsr:

; 56   :         case 's': movsd(isr, slave,  0x40/4); break;

	push	16					; 00000010H
	push	OFFSET _slave
	jmp	SHORT $LN17@InstallIsr
$LN3@InstallIsr:

; 55   :         case 'm': movsd(isr, master, 0x40/4); break;

	push	16					; 00000010H
	push	OFFSET _master
$LN17@InstallIsr:
	push	esi
	call	_movsd
	add	esp, 12					; 0000000cH
$LN4@InstallIsr:

; 58   :         }
; 59   : 
; 60   :         u32 *call = (u32*)&isr[(d == 'x') ? 0x1A : 0x18];
; 61   :         *call = (u32)&irq[i];

	mov	ecx, DWORD PTR _base$[esp+16]
	xor	eax, eax
	cmp	bl, 120					; 00000078H
	mov	ebx, DWORD PTR _irq$1$[esp+20]
	sete	al
	add	esi, 64					; 00000040H
	lea	eax, DWORD PTR [eax*2+24]
	add	eax, ebp
	add	ebp, 64					; 00000040H
	inc	edi
	mov	DWORD PTR [eax+ecx], ebx
	add	ebx, 4
	mov	DWORD PTR _irq$1$[esp+20], ebx
	cmp	ebp, 16384				; 00004000H
	jl	$LL8@InstallIsr

; 62   :     }
; 63   :     return true;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebp
	inc	eax
	pop	ebx

; 64   : }

	pop	ecx
	ret	0
_InstallIsr ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\intel\idt.c
_TEXT	SEGMENT
_err$ = 8						; size = 4
_esp$ = 12						; size = 4
_DefaultIsrStub PROC

; 32   :     u32 *ret = (u32*)&err;
; 33   :     u32 eip = ret[-1];
; 34   :     u32 irq = (eip-0x8000) / 64;
; 35   :     Logger("ISR 0x%X (eip=%X esp=%X err=%X)\n", irq, eip, esp, err);
; 36   :     return esp;

	mov	eax, DWORD PTR _esp$[esp-4]

; 37   : }

	ret	0
_DefaultIsrStub ENDP
_TEXT	ENDS
END
