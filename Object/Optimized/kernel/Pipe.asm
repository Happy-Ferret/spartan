; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\FYP\develop\spartan\Source\Kernel\Device\FileIO\Pipe.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Pipe
PUBLIC	??_C@_0BG@IHMDIKCK@?5pipe?5?5?5?5?5?5?5?5?5?5?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@ENLDIMLJ@?5pipe?9?$DOPointer?5?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@CIIKAJG@?5pipe?9?$DOLock?5?5?5?5?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@DGLDLPON@?5pipe?9?$DOCapacity?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@EAEHOPFO@?5pipe?9?$DOConsumed?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@HBJIDENF@?5pipe?9?$DOReader?5?5?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@BHHLCCGD@?5pipe?9?$DOWriter?5?5?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@EIALDFFE@?5pipe?9?$DOHead?5?5?5?5?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@MDPCJHH@?5pipe?9?$DOTail?5?5?5?5?5?$DN?5?$CFX?6?$AA@ ; `string'
PUBLIC	_pipe
;	COMDAT ??_C@_0BG@MDPCJHH@?5pipe?9?$DOTail?5?5?5?5?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@MDPCJHH@?5pipe?9?$DOTail?5?5?5?5?5?$DN?5?$CFX?6?$AA@ DB ' pipe-'
	DB	'>Tail     = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EIALDFFE@?5pipe?9?$DOHead?5?5?5?5?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@EIALDFFE@?5pipe?9?$DOHead?5?5?5?5?5?$DN?5?$CFX?6?$AA@ DB ' pipe'
	DB	'->Head     = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@BHHLCCGD@?5pipe?9?$DOWriter?5?5?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@BHHLCCGD@?5pipe?9?$DOWriter?5?5?5?$DN?5?$CFX?6?$AA@ DB ' pipe->'
	DB	'Writer   = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HBJIDENF@?5pipe?9?$DOReader?5?5?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@HBJIDENF@?5pipe?9?$DOReader?5?5?5?$DN?5?$CFX?6?$AA@ DB ' pipe->'
	DB	'Reader   = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EAEHOPFO@?5pipe?9?$DOConsumed?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@EAEHOPFO@?5pipe?9?$DOConsumed?5?$DN?5?$CFX?6?$AA@ DB ' pipe->Co'
	DB	'nsumed = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DGLDLPON@?5pipe?9?$DOCapacity?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@DGLDLPON@?5pipe?9?$DOCapacity?5?$DN?5?$CFX?6?$AA@ DB ' pipe->Ca'
	DB	'pacity = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@CIIKAJG@?5pipe?9?$DOLock?5?5?5?5?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@CIIKAJG@?5pipe?9?$DOLock?5?5?5?5?5?$DN?5?$CFX?6?$AA@ DB ' pipe-'
	DB	'>Lock     = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ENLDIMLJ@?5pipe?9?$DOPointer?5?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@ENLDIMLJ@?5pipe?9?$DOPointer?5?5?$DN?5?$CFX?6?$AA@ DB ' pipe->P'
	DB	'ointer  = %X', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@IHMDIKCK@?5pipe?5?5?5?5?5?5?5?5?5?5?5?$DN?5?$CFX?6?$AA@
CONST	SEGMENT
??_C@_0BG@IHMDIKCK@?5pipe?5?5?5?5?5?5?5?5?5?5?5?$DN?5?$CFX?6?$AA@ DB ' pi'
	DB	'pe           = %X', 0aH, 00H		; `string'
_Pipe	DD	FLAT:_pipe
_pipe	DD	FLAT:_IPipe_Create
	DD	FLAT:_IPipe_CreateAsync
	DD	FLAT:_IPipe_Destroy
	DD	FLAT:_IPipe_Read
	DD	FLAT:_IPipe_Write
	DD	FLAT:_IPipe_ReadNonBlocking
	DD	FLAT:_IPipe_WriteNonBlocking
	DD	FLAT:_IPipe_ReadAsync
	DD	FLAT:_IPipe_WriteAsync
PUBLIC	_IPipe_WriteAsync
PUBLIC	_IPipe_ReadAsync
PUBLIC	_IPipe_WriteNonBlocking
PUBLIC	_IPipe_ReadNonBlocking
PUBLIC	_IPipe_Write
PUBLIC	_IPipe_Read
PUBLIC	_IPipe_Destroy
PUBLIC	_IPipe_CreateAsync
PUBLIC	_IPipe_Create
PUBLIC	_IPipe_Debug
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_IPipe_Debug PROC

; 5    : export bool IPipe_Debug(CPipe *pipe) {

	push	esi

; 6    :     Debug(" pipe           = %X\n", pipe          );

	mov	esi, DWORD PTR _pipe$[esp]
	push	esi
	push	OFFSET ??_C@_0BG@IHMDIKCK@?5pipe?5?5?5?5?5?5?5?5?5?5?5?$DN?5?$CFX?6?$AA@
	call	_Debug

; 7    :     Debug(" pipe->Pointer  = %X\n", pipe->Pointer );

	push	DWORD PTR [esi]
	push	OFFSET ??_C@_0BG@ENLDIMLJ@?5pipe?9?$DOPointer?5?5?$DN?5?$CFX?6?$AA@
	call	_Debug

; 8    :     Debug(" pipe->Lock     = %X\n", pipe->Lock    );

	push	DWORD PTR [esi+4]
	push	OFFSET ??_C@_0BG@CIIKAJG@?5pipe?9?$DOLock?5?5?5?5?5?$DN?5?$CFX?6?$AA@
	call	_Debug

; 9    :     Debug(" pipe->Capacity = %X\n", pipe->Capacity);

	push	DWORD PTR [esi+8]
	push	OFFSET ??_C@_0BG@DGLDLPON@?5pipe?9?$DOCapacity?5?$DN?5?$CFX?6?$AA@
	call	_Debug

; 10   :     Debug(" pipe->Consumed = %X\n", pipe->Consumed);

	push	DWORD PTR [esi+12]
	push	OFFSET ??_C@_0BG@EAEHOPFO@?5pipe?9?$DOConsumed?5?$DN?5?$CFX?6?$AA@
	call	_Debug

; 11   :     Debug(" pipe->Reader   = %X\n", pipe->Reader  );

	push	DWORD PTR [esi+16]
	push	OFFSET ??_C@_0BG@HBJIDENF@?5pipe?9?$DOReader?5?5?5?$DN?5?$CFX?6?$AA@
	call	_Debug

; 12   :     Debug(" pipe->Writer   = %X\n", pipe->Writer  );

	push	DWORD PTR [esi+20]
	push	OFFSET ??_C@_0BG@BHHLCCGD@?5pipe?9?$DOWriter?5?5?5?$DN?5?$CFX?6?$AA@
	call	_Debug

; 13   :     Debug(" pipe->Head     = %X\n", pipe->Head    );

	push	DWORD PTR [esi+24]
	push	OFFSET ??_C@_0BG@EIALDFFE@?5pipe?9?$DOHead?5?5?5?5?5?$DN?5?$CFX?6?$AA@
	call	_Debug
	add	esp, 64					; 00000040H

; 14   :     Debug(" pipe->Tail     = %X\n", pipe->Tail    );

	push	DWORD PTR [esi+28]
	push	OFFSET ??_C@_0BG@MDPCJHH@?5pipe?9?$DOTail?5?5?5?5?5?$DN?5?$CFX?6?$AA@
	call	_Debug
	pop	ecx
	pop	ecx

; 15   :     return true;

	xor	eax, eax
	inc	eax
	pop	esi

; 16   : }

	ret	0
_IPipe_Debug ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_Reader$ = 12						; size = 4
_Writer$ = 16						; size = 4
_IPipe_Create PROC

; 19   :     if (!pipe) return false;

	mov	ecx, DWORD PTR _pipe$[esp-4]
	test	ecx, ecx
	jne	SHORT $LN1@IPipe_Crea
	xor	eax, eax

; 30   : }

	ret	0
$LN1@IPipe_Crea:

; 20   :     u8 *base = (u8*)pipe;
; 21   :     pipe->Pointer = &base[sizeof(CPipe)];

	lea	eax, DWORD PTR [ecx+32]

; 22   :     pipe->Lock = 0;
; 23   :     pipe->Capacity = 4*KB - sizeof(CPipe);

	mov	DWORD PTR [ecx+8], 4064			; 00000fe0H
	mov	DWORD PTR [ecx], eax
	xor	edx, edx

; 24   :     pipe->Consumed = 0;
; 25   :     pipe->Reader = Reader;

	mov	eax, DWORD PTR _Reader$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 26   :     pipe->Writer = Writer;

	mov	eax, DWORD PTR _Writer$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 27   :     pipe->Head = 0;
; 28   :     pipe->Tail = 0;
; 29   :     return true;

	xor	eax, eax
	mov	DWORD PTR [ecx+4], edx
	inc	eax
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+24], edx
	mov	DWORD PTR [ecx+28], edx

; 30   : }

	ret	0
_IPipe_Create ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_Reader$ = 12						; size = 4
_Writer$ = 16						; size = 4
_IPipe_CreateAsync PROC

; 33   :     if (!pipe) return false;

	mov	ecx, DWORD PTR _pipe$[esp-4]
	test	ecx, ecx
	jne	SHORT $LN1@IPipe_Crea
	xor	eax, eax

; 44   : }

	ret	0
$LN1@IPipe_Crea:

; 34   :     u8 *base = (u8*)pipe;
; 35   :     pipe->Pointer = &base[sizeof(CPipe)];

	lea	eax, DWORD PTR [ecx+32]

; 36   :     pipe->Lock = 0;
; 37   :     pipe->Capacity = 4*KB - sizeof(CPipe);

	mov	DWORD PTR [ecx+8], 4064			; 00000fe0H
	mov	DWORD PTR [ecx], eax
	xor	edx, edx

; 38   :     pipe->Consumed = 0;
; 39   :     pipe->Reader = Reader;

	mov	eax, DWORD PTR _Reader$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 40   :     pipe->Writer = Writer;

	mov	eax, DWORD PTR _Writer$[esp-4]
	mov	DWORD PTR [ecx+20], eax

; 41   :     pipe->Head = 0;
; 42   :     pipe->Tail = 0;
; 43   :     return true;

	xor	eax, eax
	mov	DWORD PTR [ecx+4], edx
	inc	eax
	mov	DWORD PTR [ecx+12], edx
	mov	DWORD PTR [ecx+24], edx
	mov	DWORD PTR [ecx+28], edx

; 44   : }

	ret	0
_IPipe_CreateAsync ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_IPipe_Destroy PROC

; 47   :     if (!pipe) return false;

	mov	eax, DWORD PTR _pipe$[esp-4]
	test	eax, eax
	jne	SHORT $LN2@IPipe_Dest
$LN5@IPipe_Dest:
	xor	eax, eax

; 51   : }

	ret	0
$LN2@IPipe_Dest:

; 48   :     if (!pipe->Pointer) return false;

	cmp	DWORD PTR [eax], 0
	je	SHORT $LN5@IPipe_Dest

; 49   :     stosd(pipe, 0, 4*KB/4);

	push	1024					; 00000400H
	push	0
	push	eax
	call	_stosd

; 50   :     return true;

	xor	eax, eax
	add	esp, 12					; 0000000cH
	inc	eax

; 51   : }

	ret	0
_IPipe_Destroy ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IPipe_Read PROC

; 53   : bool IPipe_Read(CPipe *pipe, u8 *buf, u32 len) {

	push	ebx
	push	ebp
	push	esi

; 54   :     if (!pipe || !buf || len == 0) return false;

	mov	esi, DWORD PTR _pipe$[esp+8]
	push	edi
	test	esi, esi
	je	SHORT $LN11@IPipe_Read
	mov	ebx, DWORD PTR _buf$[esp+12]
	test	ebx, ebx
	je	SHORT $LN11@IPipe_Read
	mov	edi, DWORD PTR _len$[esp+12]
	test	edi, edi
	je	SHORT $LN11@IPipe_Read

; 55   :     if (!pipe->Pointer) return false;

	xor	ebp, ebp
	cmp	DWORD PTR [esi], ebp
	je	SHORT $LN11@IPipe_Read

; 56   :     while (len > 0) {

	test	edi, edi
	je	SHORT $LN8@IPipe_Read
	jmp	SHORT $LN34@IPipe_Read
$LL7@IPipe_Read:

; 57   :         while (pipe->Consumed == 0) Thread->Yield();

	mov	eax, DWORD PTR _Thread
	call	DWORD PTR [eax+24]
$LN34@IPipe_Read:
	cmp	DWORD PTR [esi+12], ebp
	je	SHORT $LL7@IPipe_Read
	jmp	SHORT $LN35@IPipe_Read
$LL2@IPipe_Read:

; 58   :         do {
; 59   :             while (pipe->Lock) Thread->Yield();

	mov	eax, DWORD PTR _Thread
	call	DWORD PTR [eax+24]
$LN35@IPipe_Read:
	cmp	DWORD PTR [esi+4], ebp
	jne	SHORT $LL2@IPipe_Read

; 60   :             pipe->Lock = pipe->Reader;

	mov	eax, DWORD PTR [esi+16]

; 61   :         } while (pipe->Lock != pipe->Reader);
; 62   : 
; 63   :         pipe->Consumed--;
; 64   :         *buf++ = pipe->Pointer[pipe->Head % pipe->Capacity];

	xor	edx, edx
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [esi+24]
	div	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	dec	DWORD PTR [esi+12]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ebx], al
	inc	ebx

; 65   :         pipe->Head++;

	inc	DWORD PTR [esi+24]

; 66   :         len--;
; 67   :         pipe->Lock = 0;

	mov	DWORD PTR [esi+4], ebp
	dec	edi
	jne	SHORT $LN34@IPipe_Read
$LN8@IPipe_Read:

; 68   :     }
; 69   :     return true;

	xor	eax, eax
	inc	eax
	jmp	SHORT $LN13@IPipe_Read
$LN11@IPipe_Read:

; 54   :     if (!pipe || !buf || len == 0) return false;

	xor	eax, eax
$LN13@IPipe_Read:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 70   : }

	ret	0
_IPipe_Read ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IPipe_Write PROC

; 72   : bool IPipe_Write(CPipe *pipe, u8 *buf, u32 len) {

	push	ebx
	push	ebp
	push	esi

; 73   :     if (!pipe || !buf || len == 0) return false;

	mov	esi, DWORD PTR _pipe$[esp+8]
	push	edi
	test	esi, esi
	je	SHORT $LN11@IPipe_Writ
	mov	ebx, DWORD PTR _buf$[esp+12]
	test	ebx, ebx
	je	SHORT $LN11@IPipe_Writ
	mov	edi, DWORD PTR _len$[esp+12]
	test	edi, edi
	je	SHORT $LN11@IPipe_Writ

; 74   :     if (!pipe->Pointer) return false;

	xor	ebp, ebp
	cmp	DWORD PTR [esi], ebp
	je	SHORT $LN11@IPipe_Writ

; 75   :     while (len > 0) {

	test	edi, edi
	je	SHORT $LN8@IPipe_Writ

; 76   :         while (pipe->Consumed == pipe->Capacity) Thread->Yield();

	jmp	SHORT $LL9@IPipe_Writ
$LL7@IPipe_Writ:
	mov	eax, DWORD PTR _Thread
	call	DWORD PTR [eax+24]
$LL9@IPipe_Writ:
	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+8]
	je	SHORT $LL7@IPipe_Writ
	jmp	SHORT $LN35@IPipe_Writ
$LL2@IPipe_Writ:

; 77   :         do {
; 78   :             while (pipe->Lock) Thread->Yield();

	mov	eax, DWORD PTR _Thread
	call	DWORD PTR [eax+24]
$LN35@IPipe_Writ:
	cmp	DWORD PTR [esi+4], ebp
	jne	SHORT $LL2@IPipe_Writ

; 79   :             pipe->Lock = pipe->Writer;

	mov	eax, DWORD PTR [esi+20]

; 80   :         } while (pipe->Lock != pipe->Writer);
; 81   : 
; 82   :         pipe->Consumed++;
; 83   :         pipe->Pointer[pipe->Tail % pipe->Capacity] = *buf++;

	xor	edx, edx
	mov	DWORD PTR [esi+4], eax
	mov	eax, DWORD PTR [esi+28]
	div	DWORD PTR [esi+8]
	inc	DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [edx+ecx], al

; 84   :         pipe->Tail++;

	inc	DWORD PTR [esi+28]

; 85   :         len--;
; 86   :         pipe->Lock = 0;

	mov	DWORD PTR [esi+4], ebp
	dec	edi
	jne	SHORT $LL9@IPipe_Writ
$LN8@IPipe_Writ:

; 87   :     }
; 88   :     return true;

	xor	eax, eax
	inc	eax
	jmp	SHORT $LN13@IPipe_Writ
$LN11@IPipe_Writ:

; 73   :     if (!pipe || !buf || len == 0) return false;

	xor	eax, eax
$LN13@IPipe_Writ:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 89   : }

	ret	0
_IPipe_Write ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IPipe_ReadNonBlocking PROC

; 92   :     if (!pipe || !buf || len == 0) return false;

	mov	ecx, DWORD PTR _pipe$[esp-4]
	push	esi
	push	edi
	test	ecx, ecx
	je	SHORT $LN6@IPipe_Read
	mov	edi, DWORD PTR _buf$[esp+4]
	test	edi, edi
	je	SHORT $LN6@IPipe_Read
	mov	esi, DWORD PTR _len$[esp+4]
	test	esi, esi
	je	SHORT $LN6@IPipe_Read

; 93   :     if (!pipe->Pointer) return false;

	cmp	DWORD PTR [ecx], 0
	je	SHORT $LN6@IPipe_Read

; 94   :     while (len > 0) {

	test	esi, esi
	je	SHORT $LN3@IPipe_Read
$LL4@IPipe_Read:

; 95   :         if (pipe->Consumed == 0) pipe->Tail++;

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	jne	SHORT $LN2@IPipe_Read
	inc	DWORD PTR [ecx+28]
	jmp	SHORT $LN1@IPipe_Read
$LN2@IPipe_Read:

; 96   :         else pipe->Consumed--;

	dec	eax
	mov	DWORD PTR [ecx+12], eax
$LN1@IPipe_Read:

; 97   : 
; 98   :         *buf++ = pipe->Pointer[pipe->Head % pipe->Capacity];

	mov	eax, DWORD PTR [ecx+24]
	xor	edx, edx
	div	DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [edi], al
	inc	edi

; 99   :         pipe->Head++;

	inc	DWORD PTR [ecx+24]

; 100  :         len--;

	dec	esi
	jne	SHORT $LL4@IPipe_Read
$LN3@IPipe_Read:

; 101  :     }
; 102  :     return true;

	xor	eax, eax
	inc	eax
	jmp	SHORT $LN8@IPipe_Read
$LN6@IPipe_Read:

; 92   :     if (!pipe || !buf || len == 0) return false;

	xor	eax, eax
$LN8@IPipe_Read:
	pop	edi
	pop	esi

; 103  : }

	ret	0
_IPipe_ReadNonBlocking ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IPipe_WriteNonBlocking PROC

; 105  : bool IPipe_WriteNonBlocking(CPipe *pipe, u8 *buf, u32 len) {

	push	ebx
	push	esi

; 106  :     if (!pipe || !buf || len == 0) return false;

	mov	esi, DWORD PTR _pipe$[esp+4]
	push	edi
	test	esi, esi
	je	SHORT $LN6@IPipe_Writ
	mov	ebx, DWORD PTR _buf$[esp+8]
	test	ebx, ebx
	je	SHORT $LN6@IPipe_Writ
	mov	edi, DWORD PTR _len$[esp+8]
	test	edi, edi
	je	SHORT $LN6@IPipe_Writ

; 107  :     if (!pipe->Pointer) return false;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN6@IPipe_Writ

; 108  :     while (len > 0) {

	test	edi, edi
	je	SHORT $LN3@IPipe_Writ
$LL4@IPipe_Writ:

; 109  :         if (pipe->Consumed == pipe->Capacity) pipe->Head++;

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN2@IPipe_Writ
	inc	DWORD PTR [esi+24]
	jmp	SHORT $LN1@IPipe_Writ
$LN2@IPipe_Writ:

; 110  :         else pipe->Consumed++;

	inc	eax
	mov	DWORD PTR [esi+12], eax
$LN1@IPipe_Writ:

; 111  : 
; 112  :         pipe->Pointer[pipe->Tail % pipe->Capacity] = *buf++;

	mov	eax, DWORD PTR [esi+28]
	xor	edx, edx
	div	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [edx+ecx], al

; 113  :         pipe->Tail++;

	inc	DWORD PTR [esi+28]

; 114  :         len--;

	dec	edi
	jne	SHORT $LL4@IPipe_Writ
$LN3@IPipe_Writ:

; 115  :     }
; 116  :     return true;

	xor	eax, eax
	inc	eax
	jmp	SHORT $LN8@IPipe_Writ
$LN6@IPipe_Writ:

; 106  :     if (!pipe || !buf || len == 0) return false;

	xor	eax, eax
$LN8@IPipe_Writ:
	pop	edi
	pop	esi
	pop	ebx

; 117  : }

	ret	0
_IPipe_WriteNonBlocking ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IPipe_ReadAsync PROC

; 119  : bool IPipe_ReadAsync(CPipeAsync *pipe, u8 *buf, u32 len) {

	push	ebx
	push	esi

; 120  :     if (!pipe || !buf || len == 0) return false;

	mov	esi, DWORD PTR _pipe$[esp+4]
	push	edi
	test	esi, esi
	je	SHORT $LN9@IPipe_Read
	mov	ebx, DWORD PTR _buf$[esp+8]
	test	ebx, ebx
	je	SHORT $LN9@IPipe_Read
	mov	edi, DWORD PTR _len$[esp+8]
	test	edi, edi
	je	SHORT $LN9@IPipe_Read

; 121  :     if (!pipe->Pointer) return false;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN9@IPipe_Read

; 122  :     while (len > 0) {

	test	edi, edi
	je	SHORT $LN6@IPipe_Read
$LL7@IPipe_Read:

; 123  :         if (pipe->Consumed == 0) {

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN5@IPipe_Read

; 124  :             if (pipe->Writer) pipe->Writer((CPipe*)pipe);

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN4@IPipe_Read
	push	esi
	call	eax
	pop	ecx
	jmp	SHORT $LN2@IPipe_Read
$LN4@IPipe_Read:

; 125  :             else pipe->Tail++;

	inc	DWORD PTR [esi+28]

; 126  :         } else pipe->Consumed--;

	jmp	SHORT $LN2@IPipe_Read
$LN5@IPipe_Read:
	dec	eax
	mov	DWORD PTR [esi+12], eax
$LN2@IPipe_Read:

; 127  : 
; 128  :         *buf++ = pipe->Pointer[pipe->Head % pipe->Capacity];

	mov	eax, DWORD PTR [esi+24]
	xor	edx, edx
	div	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR [ebx], al
	inc	ebx

; 129  :         pipe->Head++;

	inc	DWORD PTR [esi+24]

; 130  :         len--;

	dec	edi
	jne	SHORT $LL7@IPipe_Read
$LN6@IPipe_Read:

; 131  :     }
; 132  :     if (pipe->Writer) pipe->Writer((CPipe*)pipe);

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN1@IPipe_Read
	push	esi
	call	eax
	pop	ecx
$LN1@IPipe_Read:

; 133  :     return true;

	xor	eax, eax
	inc	eax
	jmp	SHORT $LN11@IPipe_Read
$LN9@IPipe_Read:

; 120  :     if (!pipe || !buf || len == 0) return false;

	xor	eax, eax
$LN11@IPipe_Read:
	pop	edi
	pop	esi
	pop	ebx

; 134  : }

	ret	0
_IPipe_ReadAsync ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\fileio\pipe.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IPipe_WriteAsync PROC

; 136  : bool IPipe_WriteAsync(CPipeAsync *pipe, u8 *buf, u32 len) {

	push	ebx
	push	esi

; 137  :     if (!pipe || !buf || len == 0) return false;

	mov	esi, DWORD PTR _pipe$[esp+4]
	push	edi
	test	esi, esi
	je	SHORT $LN9@IPipe_Writ
	mov	ebx, DWORD PTR _buf$[esp+8]
	test	ebx, ebx
	je	SHORT $LN9@IPipe_Writ
	mov	edi, DWORD PTR _len$[esp+8]
	test	edi, edi
	je	SHORT $LN9@IPipe_Writ

; 138  :     if (!pipe->Pointer) return false;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN9@IPipe_Writ

; 139  :     while (len > 0) {

	test	edi, edi
	je	SHORT $LN6@IPipe_Writ
$LL7@IPipe_Writ:

; 140  :         if (pipe->Consumed == pipe->Capacity) {

	mov	eax, DWORD PTR [esi+12]
	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN5@IPipe_Writ

; 141  :             if (pipe->Reader) pipe->Reader((CPipe*)pipe);

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN4@IPipe_Writ
	push	esi
	call	eax
	pop	ecx
	jmp	SHORT $LN2@IPipe_Writ
$LN4@IPipe_Writ:

; 142  :             else pipe->Head++;

	inc	DWORD PTR [esi+24]

; 143  :         } else pipe->Consumed++;

	jmp	SHORT $LN2@IPipe_Writ
$LN5@IPipe_Writ:
	inc	eax
	mov	DWORD PTR [esi+12], eax
$LN2@IPipe_Writ:

; 144  : 
; 145  :         pipe->Pointer[pipe->Tail % pipe->Capacity] = *buf++;

	mov	eax, DWORD PTR [esi+28]
	xor	edx, edx
	div	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	mov	al, BYTE PTR [ebx]
	inc	ebx
	mov	BYTE PTR [edx+ecx], al

; 146  :         pipe->Tail++;

	inc	DWORD PTR [esi+28]

; 147  :         len--;

	dec	edi
	jne	SHORT $LL7@IPipe_Writ
$LN6@IPipe_Writ:

; 148  :     }
; 149  :     if (pipe->Reader) pipe->Reader((CPipe*)pipe);

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN1@IPipe_Writ
	push	esi
	call	eax
	pop	ecx
$LN1@IPipe_Writ:

; 150  :     return true;

	xor	eax, eax
	inc	eax
	jmp	SHORT $LN11@IPipe_Writ
$LN9@IPipe_Writ:

; 137  :     if (!pipe || !buf || len == 0) return false;

	xor	eax, eax
$LN11@IPipe_Writ:
	pop	edi
	pop	esi
	pop	ebx

; 151  : }

	ret	0
_IPipe_WriteAsync ENDP
_TEXT	ENDS
END
