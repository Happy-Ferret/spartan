; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\FYP\develop\spartan\Source\Kernel\Memory\Paging\Paging.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Paging
PUBLIC	_paging
_Paging	DD	FLAT:_paging
_paging	DD	FLAT:_IPaging_AppPages
PUBLIC	_IPaging_AppPages
PUBLIC	_EnablePaging
PUBLIC	_InstallPaging
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\paging\paging.c
_TEXT	SEGMENT
_tbl0$1$ = -8						; size = 4
_tbl3$1$ = -4						; size = 4
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallPaging PROC

; 25   : bool InstallPaging(u8 *base, u32 size) {

	push	ecx
	push	ecx

; 26   :     NOTE("ring0 page directory has full visibility of the entire address space")
; 27   :     NOTE("ring3 page directory has no visibility of most of the address space")
; 28   :     NOTE("ring3 can see a locked down version of the kernels address space")
; 29   : 
; 30   :     u32 *tbl0 = (u32*)Monitor->GetBase('TBL0');

	mov	eax, DWORD PTR _Monitor
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	1413631024				; 54424c30H
	call	DWORD PTR [eax+24]

; 31   :     u32 *tbl3 = (u32*)Monitor->GetBase('TBL3');

	mov	ecx, DWORD PTR _Monitor
	mov	ebx, eax
	mov	DWORD PTR _tbl0$1$[esp+28], ebx
	mov	DWORD PTR [esp], 1413631027		; 54424c33H
	call	DWORD PTR [ecx+24]
	mov	ebp, eax

; 32   :     stosd(tbl3, 0, 16*KB/4);

	mov	DWORD PTR [esp], 4096			; 00001000H
	xor	esi, esi
	mov	DWORD PTR _tbl3$1$[esp+28], ebp
	push	esi
	push	ebp
	call	_stosd

; 33   :     for (int i = 0; i < 1024*1024; i++) {

	mov	edi, ebx
	add	esp, 12					; 0000000cH
	mov	edx, esi
	mov	ecx, ebp
	sub	edi, ebp
	mov	ebx, 1048576				; 00100000H
$LL10@InstallPag:

; 34   :         u32 page = i*4*KB;
; 35   :         tbl0[i] = page | RING3_RWX;

	mov	eax, edx
	or	eax, 7
	mov	DWORD PTR [edi+ecx], eax

; 36   :         if (page < 16*MB) tbl3[i] = page | RING3_RWX;

	cmp	edx, 16777216				; 01000000H
	jae	SHORT $LN9@InstallPag
	mov	DWORD PTR [ecx], eax
$LN9@InstallPag:

; 33   :     for (int i = 0; i < 1024*1024; i++) {

	add	edx, 4096				; 00001000H
	add	ecx, 4
	dec	ebx
	jne	SHORT $LL10@InstallPag

; 37   :     }
; 38   : 
; 39   :     u32 *dir0 = (u32*)base;
; 40   :     u32 *dir3 = (u32*)&base[4*KB];

	mov	ecx, DWORD PTR _base$[esp+20]
	mov	ebx, esi
	mov	ebp, DWORD PTR _tbl0$1$[esp+24]
	lea	edi, DWORD PTR [ecx+4096]
$LL6@InstallPag:

; 41   :     for (int i = 0; i < 1024; i++) {
; 42   :         u32 page = (u32)&tbl0[i*4*KB/4];

	mov	eax, ebx
	add	ebx, 4096				; 00001000H
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp

; 43   :         dir0[i] = page | RING3_RWX;

	or	eax, 7
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	cmp	ebx, 4194304				; 00400000H
	jl	SHORT $LL6@InstallPag

; 44   :     }
; 45   : 
; 46   :     stosd(dir3, 0, 4*KB/4);

	push	1024					; 00000400H
	push	esi
	push	edi
	call	_stosd
	mov	ebp, DWORD PTR _tbl3$1$[esp+36]
	add	esp, 12					; 0000000cH
$LL3@InstallPag:

; 47   :     for (int i = 0; i < 4; i++) {
; 48   :         u32 page = (u32)&tbl3[i*4*KB/4];

	mov	eax, esi
	add	esi, 4096				; 00001000H
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	lea	eax, DWORD PTR [eax*4]
	add	eax, ebp

; 49   :         dir3[i] = page | RING3_RWX;

	or	eax, 7
	mov	DWORD PTR [edi], eax
	lea	edi, DWORD PTR [edi+4]
	cmp	esi, 16384				; 00004000H
	jl	SHORT $LL3@InstallPag

; 50   :     }
; 51   :     return true;

	pop	edi
	pop	esi
	xor	eax, eax
	pop	ebp
	inc	eax
	pop	ebx

; 52   : }

	pop	ecx
	pop	ecx
	ret	0
_InstallPaging ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\paging\paging.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_EnablePaging PROC

; 55   :     set_cr3(base);

	push	DWORD PTR _base$[esp-4]
	call	_set_cr3

; 56   :     set_cr0(get_cr0() | CR0_PG | CR0_PE);

	call	_get_cr0
	or	eax, -2147483647			; 80000001H
	push	eax
	call	_set_cr0
	pop	ecx

; 57   :     return true;

	xor	eax, eax
	pop	ecx
	inc	eax

; 58   : }

	ret	0
_EnablePaging ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\paging\paging.c
_TEXT	SEGMENT
_pcb$ = 8						; size = 4
_IPaging_AppPages PROC

; 60   : bool IPaging_AppPages(CPcb *pcb) {

	push	edi

; 61   :     if (!pcb) return false;

	mov	edi, DWORD PTR _pcb$[esp]
	test	edi, edi
	jne	SHORT $LN5@IPaging_Ap
$LN12@IPaging_Ap:
	xor	eax, eax
	pop	edi

; 78   : }

	ret	0
$LN5@IPaging_Ap:

; 62   :     CPeb *peb = pcb->Peb;

	mov	eax, DWORD PTR [edi+20]

; 63   :     if (!peb) return false;

	test	eax, eax
	je	SHORT $LN12@IPaging_Ap

; 64   : 
; 65   :     u32 *dir = peb->Pages;

	push	ebx
	push	ebp
	mov	ebp, DWORD PTR [eax+24]

; 66   :     u32 *tbl0 = (u32*)Monitor->GetBase('TBL0');

	mov	eax, DWORD PTR _Monitor
	push	esi
	push	1413631024				; 54424c30H
	call	DWORD PTR [eax+24]

; 67   :     u32 *dir0 = (u32*)Monitor->GetBase('PAGE');

	mov	eax, DWORD PTR _Monitor
	mov	DWORD PTR [esp], 1346455365		; 50414745H
	call	DWORD PTR [eax+24]

; 68   :     stosd(dir, 0, 4*KB/4);

	mov	DWORD PTR [esp], 1024			; 00000400H
	mov	ebx, eax
	push	0
	push	ebp
	call	_stosd

; 69   :     movsd(dir, dir0, 8);

	push	8
	push	ebx
	push	ebp
	call	_movsd

; 70   : 
; 71   :     u32 s = pcb->Binary / (4*MB);
; 72   :     u32 f = (pcb->Binary + pcb->Extent) / (4*MB);

	mov	eax, DWORD PTR [edi+44]
	mov	ecx, 4194303				; 003fffffH
	add	eax, DWORD PTR [edi+8]
	add	esp, 24					; 00000018H
	cdq
	and	edx, ecx
	lea	esi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [edi+8]
	cdq
	and	edx, ecx
	sar	esi, 22					; 00000016H
	add	eax, edx
	sar	eax, 22					; 00000016H

; 73   :     for (u32 i = s; i < f; i++) {

	cmp	eax, esi
	jae	SHORT $LN1@IPaging_Ap
	lea	ecx, DWORD PTR [eax*4]
	sub	ebx, ebp
	add	ecx, ebp
	sub	esi, eax
$LL3@IPaging_Ap:

; 74   :         u32 page = dir0[i] & ~RING3_RWX;
; 75   :         dir[i] = page | RING3_RWX;

	mov	eax, DWORD PTR [ebx+ecx]
	or	eax, 7
	mov	DWORD PTR [ecx], eax
	lea	ecx, DWORD PTR [ecx+4]
	dec	esi
	jne	SHORT $LL3@IPaging_Ap
$LN1@IPaging_Ap:
	pop	esi
	pop	ebp

; 76   :     }
; 77   :     return true;

	xor	eax, eax
	pop	ebx
	inc	eax
	pop	edi

; 78   : }

	ret	0
_IPaging_AppPages ENDP
_TEXT	ENDS
END
