; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\BootLoad\PcBios\Ps2.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Ps2Command
PUBLIC	_Ps2Ack
PUBLIC	_Ps2Read
PUBLIC	_Ps2Send
PUBLIC	_Ps2Wait
PUBLIC	_EnablePs2
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\pcbios\ps2.c
_TEXT	SEGMENT
_EnablePs2 PROC

; 48   : bool EnablePs2(void) {

	push	ebx

; 49   :     Ps2Read();

	call	_Ps2Read

; 50   :     Ps2Wait(1);

	mov	cl, 1
	call	_Ps2Wait

; 51   :     outb(PS2_STATUS, 0xA8);

	push	168					; 000000a8H
	push	100					; 00000064H
	call	_outb

; 52   :     Ps2Wait(1);

	mov	cl, 1
	call	_Ps2Wait

; 53   :     outb(PS2_STATUS, 0x20);

	push	32					; 00000020H
	push	100					; 00000064H
	call	_outb

; 54   :     Ps2Wait(0);

	xor	cl, cl
	call	_Ps2Wait

; 55   :     u8 status = inb(PS2_DATA);

	push	96					; 00000060H
	call	_inb

; 56   :     Ps2Wait(1);

	mov	cl, 1
	mov	bl, al
	call	_Ps2Wait

; 57   :     outb(PS2_STATUS, 0x60);

	push	96					; 00000060H
	push	100					; 00000064H
	call	_outb

; 58   :     Ps2Wait(1);

	mov	cl, 1
	call	_Ps2Wait

; 59   :     outb(PS2_DATA, (status|3) & ~0x10);

	movzx	eax, bl
	and	eax, -17				; ffffffefH
	or	eax, 3
	push	eax
	push	96					; 00000060H
	call	_outb
	add	esp, 36					; 00000024H

; 60   :     Ps2Send(0xF6);

	mov	cl, 246					; 000000f6H
	call	_Ps2Send

; 61   :     Ps2Read();

	call	_Ps2Read

; 62   :     Ps2Send(0xF4);

	mov	cl, 244					; 000000f4H
	call	_Ps2Send

; 63   :     Ps2Read();

	call	_Ps2Read

; 64   :     return true;

	xor	eax, eax
	inc	eax
	pop	ebx

; 65   : }

	ret	0
_EnablePs2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\pcbios\ps2.c
_TEXT	SEGMENT
_Ps2Wait PROC
; _type$ = cl

; 4    :     u8 mask = (type) ? 2 : 1;

	test	cl, cl
	push	ebx
	setne	dl
	inc	dl

; 5    :     u8 test = (type) ? 0 : 1;

	test	cl, cl
	push	esi
	sete	al

; 6    :     for (u32 t = 100000; t; t--) {

	mov	esi, 100000				; 000186a0H
	push	edi
	movzx	edi, dl
	movzx	ebx, al
$LL4@Ps2Wait:

; 7    :         if ((inb(PS2_STATUS) & mask) == test) {

	push	100					; 00000064H
	call	_inb
	and	eax, edi
	pop	ecx
	cmp	eax, ebx
	je	SHORT $LN8@Ps2Wait

; 6    :     for (u32 t = 100000; t; t--) {

	dec	esi
	jne	SHORT $LL4@Ps2Wait
$LN8@Ps2Wait:
	pop	edi
	pop	esi
	pop	ebx

; 8    :             break;
; 9    :         }
; 10   :     }
; 11   :     return;
; 12   : }

	ret	0
_Ps2Wait ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\pcbios\ps2.c
_TEXT	SEGMENT
_Ps2Send PROC
; _value$ = cl

; 14   : void Ps2Send(u8 value) {

	push	ebx
	mov	bl, cl

; 15   :     Ps2Wait(1);

	mov	cl, 1
	call	_Ps2Wait

; 16   :     outb(PS2_STATUS, 0xD4);

	push	212					; 000000d4H
	push	100					; 00000064H
	call	_outb

; 17   :     Ps2Wait(1);

	mov	cl, 1
	call	_Ps2Wait

; 18   :     outb(PS2_DATA, value);

	movzx	eax, bl
	push	eax
	push	96					; 00000060H
	call	_outb
	add	esp, 16					; 00000010H
	pop	ebx

; 19   : }

	ret	0
_Ps2Send ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\pcbios\ps2.c
_TEXT	SEGMENT
_Ps2Read PROC

; 22   :     Ps2Wait(0);

	xor	cl, cl
	call	_Ps2Wait

; 23   :     return inb(PS2_DATA);

	push	96					; 00000060H
	call	_inb
	pop	ecx

; 24   : }

	ret	0
_Ps2Read ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\pcbios\ps2.c
_TEXT	SEGMENT
_Ps2Ack	PROC

; 26   : bool Ps2Ack(void){ 

	push	esi

; 27   :     for (int i = 0; i < 100000; i++) {

	xor	esi, esi
$LL4@Ps2Ack:

; 28   :         if (inb(PS2_DATA) == 0xFA) return true;

	push	96					; 00000060H
	call	_inb
	pop	ecx
	cmp	eax, 250				; 000000faH
	je	SHORT $LN8@Ps2Ack

; 27   :     for (int i = 0; i < 100000; i++) {

	inc	esi
	cmp	esi, 100000				; 000186a0H
	jl	SHORT $LL4@Ps2Ack

; 29   :     }
; 30   :     return false;

	xor	eax, eax
	pop	esi

; 31   : }

	ret	0
$LN8@Ps2Ack:

; 28   :         if (inb(PS2_DATA) == 0xFA) return true;

	xor	eax, eax
	inc	eax
	pop	esi

; 31   : }

	ret	0
_Ps2Ack	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\pcbios\ps2.c
_TEXT	SEGMENT
_Ps2Command PROC
; _cmd$dead$ = cl
; _val$dead$ = dl

; 38   : void Ps2Command(char cmd, char val) { 

	push	ecx
	push	ebx
	mov	bl, BYTE PTR _led

; 39   :     Ps2Wait(0);

	xor	cl, cl
	call	_Ps2Wait

; 40   :     outb(PS2_DATA, cmd);

	push	-19					; ffffffedH
	push	96					; 00000060H
	call	_outb

; 41   :     Ps2Ack();

	call	_Ps2Ack

; 42   : 
; 43   :     outb(PS2_DATA, val);

	movsx	eax, bl
	push	eax
	push	96					; 00000060H
	call	_outb
	add	esp, 16					; 00000010H

; 44   :     Ps2Wait(0);

	xor	cl, cl
	call	_Ps2Wait
	pop	ebx

; 46   : }

	add	esp, 4

; 45   :     Ps2Ack();

	jmp	_Ps2Ack
_Ps2Command ENDP
_TEXT	ENDS
END
