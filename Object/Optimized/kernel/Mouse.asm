; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\Device\Drivers\Mouse.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_MOUSE_SPEED
PUBLIC	_MOUSE_FORMAT
PUBLIC	_MOUSE_ASSIST
PUBLIC	_MOUSE_WHEEL
PUBLIC	_Mouse
PUBLIC	_MOUSE_BUTTONS
EXTRN	__imp__pow:PROC
EXTRN	__imp__pythagoras:PROC
COMM	_ms:BYTE:060H
_velocity DD	01H DUP (?)
_MOUSE_WHEEL DD	01H DUP (?)
_BSS	ENDS
_MOUSE_SPEED DD	042H
_imouse	DD	FLAT:_IMouse_Enable
	DD	FLAT:_IMouse_Flush
	DD	FLAT:_IMouse_GetSpeed
	DD	FLAT:_IMouse_SetSpeed
_MOUSE_FORMAT DD 02H
_MOUSE_ASSIST DD 01H
_Mouse	DD	FLAT:_imouse
_MOUSE_BUTTONS DD 03H
PUBLIC	_IMouse_Enable
PUBLIC	_IMouse_Flush
PUBLIC	_MouseIsr
PUBLIC	_TranslateMouse
PUBLIC	_ActiveAssist
PUBLIC	_IMouse_SetSpeed
PUBLIC	_IMouse_GetSpeed
PUBLIC	_EnableMouse
PUBLIC	_InstallMouse
	ALIGN	4

_mbuf	DB	04H DUP (?)
_pipe	DD	01H DUP (?)
_mpos	DB	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallMouse PROC

; 108  :     pipe = (CPipeAsync*)base;

	mov	eax, DWORD PTR _base$[esp-4]

; 109  :     Pipe->CreateAsync(pipe, null, null);

	push	0
	push	0
	mov	DWORD PTR _pipe, eax
	push	eax
	mov	eax, DWORD PTR _Pipe
	call	DWORD PTR [eax+4]

; 110  :     stosd(&ms, 0, sizeof(ms)/4);

	push	24					; 00000018H
	push	0
	push	OFFSET _ms
	call	_stosd

; 111  :     return true;

	xor	eax, eax
	add	esp, 24					; 00000018H
	inc	eax

; 112  : }

	ret	0
_InstallMouse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_EnableMouse PROC

; 144  :     IMouse_Enable();

	call	_IMouse_Enable

; 145  :     Device->Latch(IRQ_MOUSE, MouseIsr);

	mov	eax, DWORD PTR _Device
	push	OFFSET _MouseIsr
	push	44					; 0000002cH
	call	DWORD PTR [eax]
	pop	ecx

; 146  :     return true;

	xor	eax, eax
	pop	ecx
	inc	eax

; 147  : }

	ret	0
_EnableMouse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_IMouse_GetSpeed PROC

; 23   :     return MOUSE_SPEED;

	mov	eax, DWORD PTR _MOUSE_SPEED

; 24   : }

	ret	0
_IMouse_GetSpeed ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_speed$ = 8						; size = 4
_IMouse_SetSpeed PROC

; 27   :     if (speed <= 5) return false;

	mov	eax, DWORD PTR _speed$[esp-4]
	cmp	eax, 5
	jg	SHORT $LN1@IMouse_Set
	xor	eax, eax

; 30   : }

	ret	0
$LN1@IMouse_Set:

; 28   :     MOUSE_SPEED = speed;

	mov	DWORD PTR _MOUSE_SPEED, eax

; 29   :     return true;

	xor	eax, eax
	inc	eax

; 30   : }

	ret	0
_IMouse_SetSpeed ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_log2$1$ = -4						; size = 4
_ActiveAssist PROC
; _adj$ = ecx
; _opp$ = edx

; 32   : void ActiveAssist(int adj, int opp) {

	push	ecx
	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	ebp, edx
	mov	ebx, ecx

; 33   :     int hyp = pythagoras(adj, opp);

	push	ebp
	push	ebx
	call	DWORD PTR __imp__pythagoras

; 34   :     int log2  = pow(hyp,2);

	mov	esi, DWORD PTR __imp__pow
	mov	edi, eax
	push	2
	push	edi
	call	esi

; 35   :     int log10 = pow(hyp,10);

	push	10					; 0000000aH
	push	edi
	mov	DWORD PTR _log2$1$[esp+44], eax
	call	esi
	mov	ecx, eax
	add	esp, 24					; 00000018H

; 36   :     velocity = log10 ? velocity/2 + log2*hyp/log10 : 0;

	xor	esi, esi
	test	ecx, ecx
	je	SHORT $LN3@ActiveAssi
	mov	eax, DWORD PTR _log2$1$[esp+20]
	imul	eax, edi
	cdq
	idiv	ecx
	mov	ecx, eax
	mov	eax, DWORD PTR _velocity
	cdq
	sub	eax, edx
	sar	eax, 1
	add	ecx, eax
	jmp	SHORT $LN13@ActiveAssi
$LN3@ActiveAssi:
	mov	ecx, esi
$LN13@ActiveAssi:
	mov	DWORD PTR _velocity, ecx

; 37   :     int speed = (velocity) ? MAX(MOUSE_SPEED*velocity/128, 1) : 0;

	test	ecx, ecx
	je	SHORT $LN7@ActiveAssi
	mov	eax, DWORD PTR _MOUSE_SPEED
	imul	eax, ecx
	cdq
	and	edx, 127				; 0000007fH
	lea	ecx, DWORD PTR [edx+eax]
	sar	ecx, 7
	cmp	ecx, 1
	jg	SHORT $LN8@ActiveAssi
	xor	ecx, ecx
	inc	ecx
	jmp	SHORT $LN8@ActiveAssi
$LN7@ActiveAssi:
	mov	ecx, esi
$LN8@ActiveAssi:

; 38   :     ms[1].PosX = ms[2].PosX + (hyp ? speed*adj/hyp : 0);

	test	edi, edi
	je	SHORT $LN9@ActiveAssi
	mov	eax, ecx
	imul	eax, ebx
	cdq
	idiv	edi
	mov	edx, eax
	jmp	SHORT $LN10@ActiveAssi
$LN9@ActiveAssi:
	mov	edx, esi
$LN10@ActiveAssi:
	mov	eax, DWORD PTR _ms+64
	add	eax, edx
	mov	DWORD PTR _ms+32, eax

; 39   :     ms[1].PosY = ms[2].PosY + (hyp ? speed*opp/hyp : 0);

	test	edi, edi
	je	SHORT $LN11@ActiveAssi
	imul	ecx, ebp
	mov	eax, ecx
	cdq
	idiv	edi
	mov	esi, eax
$LN11@ActiveAssi:
	mov	eax, DWORD PTR _ms+68
	pop	edi
	add	eax, esi
	pop	esi
	pop	ebp
	mov	DWORD PTR _ms+36, eax
	pop	ebx

; 40   : }

	pop	ecx
	ret	0
_ActiveAssist ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_TranslateMouse PROC
; _adj$ = ecx
; _opp$ = edx

; 42   : void TranslateMouse(int adj, int opp) {

	push	ebx
	push	esi
	push	edi

; 43   :     movsd(&ms[2], &ms[1], sizeof(CMouse)/4); // old = new

	push	8
	mov	ebx, OFFSET _ms+32
	mov	esi, edx
	push	ebx
	push	OFFSET _ms+64
	mov	edi, ecx
	call	_movsd

; 44   :     movsd(&ms[1], &ms[0], sizeof(CMouse)/4); // new = cur

	push	8
	push	OFFSET _ms
	push	ebx
	call	_movsd
	add	esp, 24					; 00000018H

; 45   :     if (MOUSE_ASSIST) ActiveAssist(adj, opp);

	cmp	DWORD PTR _MOUSE_ASSIST, 0
	je	SHORT $LN2@TranslateM
	mov	edx, esi
	mov	ecx, edi
	call	_ActiveAssist

; 46   :     else {

	mov	edi, DWORD PTR _ms+32
	jmp	SHORT $LN1@TranslateM
$LN2@TranslateM:

; 47   :         ms[1].PosX = ms[2].PosX + adj;

	add	edi, DWORD PTR _ms+64

; 48   :         ms[1].PosY = ms[2].PosY + opp;

	mov	eax, DWORD PTR _ms+68
	add	eax, esi
	mov	DWORD PTR _ms+32, edi
	mov	DWORD PTR _ms+36, eax
$LN1@TranslateM:

; 49   :     }
; 50   :     ms[1].PosX = MIN(MAX(0, ms[1].PosX), Vesa->ResX()-1);

	xor	esi, esi
	test	edi, edi
	jns	SHORT $LN5@TranslateM
	mov	edi, esi
$LN5@TranslateM:
	mov	eax, DWORD PTR _Vesa
	call	DWORD PTR [eax]
	movzx	eax, ax
	dec	eax
	cmp	edi, eax
	jge	SHORT $LN9@TranslateM
	mov	eax, DWORD PTR _ms+32
	test	eax, eax
	jns	SHORT $LN10@TranslateM
	mov	eax, esi
	jmp	SHORT $LN10@TranslateM
$LN9@TranslateM:
	mov	eax, DWORD PTR _Vesa
	call	DWORD PTR [eax]
	movzx	eax, ax
	dec	eax
$LN10@TranslateM:

; 51   :     ms[1].PosY = MIN(MAX(0, ms[1].PosY), Vesa->ResY()-1);

	mov	edi, DWORD PTR _ms+36
	mov	DWORD PTR _ms+32, eax
	test	edi, edi
	jns	SHORT $LN11@TranslateM
	mov	edi, esi
$LN11@TranslateM:
	mov	eax, DWORD PTR _Vesa
	call	DWORD PTR [eax+4]
	movzx	eax, ax
	dec	eax
	cmp	edi, eax
	jge	SHORT $LN15@TranslateM
	mov	eax, DWORD PTR _ms+36
	test	eax, eax
	js	SHORT $LN16@TranslateM
	mov	esi, eax
	jmp	SHORT $LN16@TranslateM
$LN15@TranslateM:
	mov	eax, DWORD PTR _Vesa
	call	DWORD PTR [eax+4]
	movzx	esi, ax
	dec	esi
$LN16@TranslateM:
	pop	edi
	mov	DWORD PTR _ms+36, esi
	pop	esi
	pop	ebx

; 52   : }

	ret	0
_TranslateMouse ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_err$ = 8						; size = 4
_esp$ = 12						; size = 4
_MouseIsr PROC

; 56   :     //char round = (MOUSE_FORMAT & 4) ? 4 : 3;
; 57   :     char round = MOUSE_BUTTONS + MOUSE_WHEEL;

	mov	al, BYTE PTR _MOUSE_BUTTONS
	add	al, BYTE PTR _MOUSE_WHEEL
	push	esi

; 58   : 
; 59   :     mbuf[mpos = mpos % round] = inb(PS2_DATA);

	movsx	esi, al
	movzx	eax, BYTE PTR _mpos
	cdq
	idiv	esi
	push	96					; 00000060H
	mov	BYTE PTR _mpos, dl
	call	_inb
	mov	dl, BYTE PTR _mpos
	pop	ecx
	movzx	ecx, dl

; 60   : 
; 61   :     mpos = ++mpos % round;

	inc	dl
	mov	BYTE PTR _mbuf[ecx], al
	movzx	eax, dl
	cdq
	idiv	esi
	mov	BYTE PTR _mpos, dl

; 62   :     if (mpos == 0) {

	test	dl, dl
	jne	$LN1@MouseIsr

; 63   :         int status = mbuf[0];

	mov	eax, DWORD PTR _mbuf
	push	ebx
	movzx	ebx, al

; 64   :         if (status & 0x08) {

	test	bl, 8
	je	$LN11@MouseIsr

; 65   :             int x = (unsigned char)mbuf[1];
; 66   :             int y = (unsigned char)mbuf[2];

	movzx	esi, BYTE PTR _mbuf+2
	push	edi

; 67   :             int w = (signed char)mbuf[3];
; 68   :             if (MOUSE_WHEEL == 0) w = 0;

	mov	edi, DWORD PTR _MOUSE_WHEEL
	neg	edi
	movzx	edx, ah
	movsx	eax, BYTE PTR _mbuf+3
	sbb	edi, edi
	and	edi, eax

; 69   : 
; 70   :             if (MOUSE_FORMAT & 1) {

	test	BYTE PTR _MOUSE_FORMAT, 1
	je	SHORT $LN9@MouseIsr

; 71   :                 if (status & 0x10) x |= 0xFFFFFE00;

	mov	eax, -512				; fffffe00H
	test	bl, 16					; 00000010H
	je	SHORT $LN8@MouseIsr
	or	edx, eax
$LN8@MouseIsr:

; 72   :                 if (status & 0x20) y |= 0xFFFFFE00;

	test	bl, 32					; 00000020H
	je	SHORT $LN7@MouseIsr
	or	esi, eax
$LN7@MouseIsr:

; 73   :                 if (status & 0x40) x |= 0x100;

	mov	eax, 256				; 00000100H
	test	bl, 64					; 00000040H
	je	SHORT $LN6@MouseIsr
	or	edx, eax
$LN6@MouseIsr:

; 74   :                 if (status & 0x80) y |= 0x100;

	test	bl, bl
	jns	SHORT $LN2@MouseIsr

; 75   :             } else {

	jmp	SHORT $LN16@MouseIsr
$LN9@MouseIsr:

; 76   :                 if (status & 0x10) x |= 0xFFFFFF00;

	mov	eax, -256				; ffffff00H
	test	bl, 16					; 00000010H
	je	SHORT $LN3@MouseIsr
	or	edx, eax
$LN3@MouseIsr:

; 77   :                 if (status & 0x20) y |= 0xFFFFFF00;

	test	bl, 32					; 00000020H
	je	SHORT $LN2@MouseIsr
$LN16@MouseIsr:
	or	esi, eax
$LN2@MouseIsr:

; 78   :             }
; 79   : 
; 80   :             ms[0].DeltaX = (w) ? 0 : +x;

	mov	ecx, edi

; 81   :             ms[0].DeltaY = (w) ? 0 : -y;
; 82   :             ms[0].Wheel  = w;

	mov	DWORD PTR _ms+8, edi
	neg	ecx

; 83   :             ms[0].Left   = (status & 1);

	mov	eax, ebx
	sbb	ecx, ecx
	neg	esi
	not	ecx
	and	ecx, edx
	mov	edx, edi
	neg	edx
	mov	DWORD PTR _ms+24, ecx
	sbb	edx, edx
	and	eax, 1
	mov	DWORD PTR _ms+12, eax
	not	edx

; 84   :             ms[0].Right  = (status & 2)/2;

	mov	eax, ebx
	and	edx, esi
	sar	eax, 1

; 85   :             ms[0].Middle = (status & 4)/4;

	sar	ebx, 2
	and	eax, 1
	and	ebx, 1
	mov	DWORD PTR _ms+28, edx
	mov	DWORD PTR _ms+20, eax
	mov	DWORD PTR _ms+16, ebx

; 86   : 
; 87   :             /*
; 88   :             Logger("\n [info] Mouse [");
; 89   :             for (int i = 0; i < round; i++) Logger(" %X ", mbuf[i]);
; 90   :             Logger(" ]\n");
; 91   :             Logger("x=%d y=%d w=%d b=%s%s%s\n",
; 92   :                 ms[0].DeltaX,
; 93   :                 ms[0].DeltaY,
; 94   :                 ms[0].Wheel,
; 95   :                 ms[0].Left   ? "L" : "-",
; 96   :                 ms[0].Middle ? "M" : "-",
; 97   :                 ms[0].Right  ? "R" : "-");
; 98   :             */
; 99   : 
; 100  :             TranslateMouse(ms[0].DeltaX, ms[0].DeltaY);

	call	_TranslateMouse

; 101  :             Pipe->WriteAsync(pipe, (u8*)&ms[1], sizeof(CMouse));

	mov	eax, DWORD PTR _Pipe
	push	32					; 00000020H
	push	OFFSET _ms+32
	push	DWORD PTR _pipe
	call	DWORD PTR [eax+32]
	add	esp, 12					; 0000000cH
	pop	edi
	jmp	SHORT $LN15@MouseIsr
$LN11@MouseIsr:

; 102  :         } else ++mpos;

	mov	BYTE PTR _mpos, 1
$LN15@MouseIsr:
	pop	ebx
$LN1@MouseIsr:

; 103  :     }
; 104  :     return esp;

	mov	eax, DWORD PTR _esp$[esp]
	pop	esi

; 105  : }

	ret	0
_MouseIsr ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_IMouse_Flush PROC

; 115  :     inb(PS2_STATUS);

	push	100					; 00000064H
	call	_inb

; 116  :     inb(PS2_DATA);

	push	96					; 00000060H
	call	_inb

; 117  :     outb(PIC2_CMD, EOI);

	push	32					; 00000020H
	push	160					; 000000a0H
	call	_outb

; 118  :     outb(PIC1_CMD, EOI);

	push	32					; 00000020H
	push	32					; 00000020H
	call	_outb
	add	esp, 24					; 00000018H

; 119  : }

	ret	0
_IMouse_Flush ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\mouse.c
_TEXT	SEGMENT
_IMouse_Enable PROC

; 122  :     inb(PS2_STATUS);

	push	100					; 00000064H
	call	_inb

; 123  :     inb(PS2_DATA);

	push	96					; 00000060H
	call	_inb
	pop	ecx
	pop	ecx

; 124  :     Ps2Send(0xF2); Ps2Read();

	mov	cl, 242					; 000000f2H
	call	_Ps2Send
	call	_Ps2Read

; 125  : 	char old = Ps2Read();

	call	_Ps2Read

; 126  : 
; 127  :     Ps2Send(0xF3); Ps2Read();

	mov	cl, 243					; 000000f3H
	call	_Ps2Send
	call	_Ps2Read

; 128  :     Ps2Send(0xC8); Ps2Read();

	mov	cl, 200					; 000000c8H
	call	_Ps2Send
	call	_Ps2Read

; 129  :     Ps2Send(0xF3); Ps2Read();

	mov	cl, 243					; 000000f3H
	call	_Ps2Send
	call	_Ps2Read

; 130  :     Ps2Send(0x64); Ps2Read();

	mov	cl, 100					; 00000064H
	call	_Ps2Send
	call	_Ps2Read

; 131  :     Ps2Send(0xF3); Ps2Read();

	mov	cl, 243					; 000000f3H
	call	_Ps2Send
	call	_Ps2Read

; 132  :     Ps2Send(0x50); Ps2Read();

	mov	cl, 80					; 00000050H
	call	_Ps2Send
	call	_Ps2Read

; 133  :     Ps2Send(0xF2); Ps2Read();

	mov	cl, 242					; 000000f2H
	call	_Ps2Send
	call	_Ps2Read

; 134  :     if (Ps2Read() == 3) MOUSE_WHEEL = 1;

	call	_Ps2Read
	cmp	al, 3
	jne	SHORT $LN1@IMouse_Ena
	mov	DWORD PTR _MOUSE_WHEEL, 1
$LN1@IMouse_Ena:

; 135  :     if (MOUSE_WHEEL) Logger(" Mouse Wheel Detected\n");
; 136  :     MOUSE_BUTTONS = 3;
; 137  : 
; 138  :     ms[2].PosX = ms[1].PosX = ms[0].PosX = Vesa->ResX()/2;

	mov	eax, DWORD PTR _Vesa
	mov	DWORD PTR _MOUSE_BUTTONS, 3
	call	DWORD PTR [eax]
	movzx	ecx, ax
	shr	ecx, 1
	mov	DWORD PTR _ms, ecx
	mov	DWORD PTR _ms+32, ecx
	mov	DWORD PTR _ms+64, ecx

; 139  :     ms[2].PosY = ms[1].PosY = ms[0].PosY = Vesa->ResY()/2;

	mov	ecx, DWORD PTR _Vesa
	call	DWORD PTR [ecx+4]
	movzx	ecx, ax

; 140  :     return true;

	xor	eax, eax
	shr	ecx, 1
	inc	eax
	mov	DWORD PTR _ms+4, ecx
	mov	DWORD PTR _ms+36, ecx
	mov	DWORD PTR _ms+68, ecx

; 141  : }

	ret	0
_IMouse_Enable ENDP
_TEXT	ENDS
END
