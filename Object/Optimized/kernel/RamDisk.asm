; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\Device\Drivers\RamDisk.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_RamDisk
PUBLIC	_ramdisk
EXTRN	__imp__Swap:PROC
EXTRN	__imp__BinarySearch:PROC
EXTRN	__imp__StrLen:PROC
EXTRN	__imp__BubbleSort:PROC
_RamDisk DD	FLAT:_ramdisk
_ramdisk DD	FLAT:_DiskFormat
	DD	FLAT:_DiskInsert
	DD	FLAT:_DiskRemove
	DD	FLAT:_DiskSearch
PUBLIC	_DiskRemove
PUBLIC	_DiskInsert
PUBLIC	_DiskSearch
PUBLIC	_DiskAlloc
PUBLIC	_DiskFormat
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\ramdisk.c
_TEXT	SEGMENT
_volume$ = 8						; size = 4
_size$ = 12						; size = 4
_VolumeID$ = 16						; size = 4
_DiskFormat PROC

; 6    : int DiskFormat(CDisk *volume, int size, char *VolumeID) {

	push	ebp
	mov	ebp, esp
	push	edi

; 7    :     if (!volume) return 0;

	mov	edi, DWORD PTR _volume$[ebp]
	test	edi, edi
	jne	SHORT $LN2@DiskFormat
	xor	eax, eax
	jmp	$LN3@DiskFormat
$LN2@DiskFormat:
	push	ebx
	push	esi

; 8    :     char *disk = (char*)volume;
; 9    : 
; 10   :     stosd(volume, 0, 256/4);

	push	64					; 00000040H
	xor	ebx, ebx
	push	ebx
	push	edi
	call	_stosd

; 11   :     if (StrLen(VolumeID) > sizeof(volume->VolumeID)) {

	push	DWORD PTR _VolumeID$[ebp]
	mov	esi, DWORD PTR __imp__StrLen
	call	esi
	add	esp, 16					; 00000010H
	cmp	eax, 32					; 00000020H
	jbe	SHORT $LN1@DiskFormat

; 12   :         return 0; // Error("RamDisk.Format [fail] VolumeID is too long! %s > 32 characters\n", path);

	xor	eax, eax
	jmp	$LN5@DiskFormat
$LN1@DiskFormat:

; 13   :     }
; 14   : 
; 15   :     volume->DiskBase  = (int)volume;
; 16   :     volume->DiskSize  = size;

	mov	eax, DWORD PTR _size$[ebp]

; 17   :     volume->Capacity  = 4*KB-256;
; 18   :     volume->Geometry  = 256;
; 19   :     volume->NodeList  = 4*KB;
; 20   :     volume->FileData  = 64*4*KB;
; 21   :     volume->NodeCount = 0;
; 22   :     volume->FileCount = 0;
; 23   :     volume->NextNode  = volume->FileData/(4*KB);
; 24   :     volume->NextFile  = volume->Capacity/(4*KB);
; 25   : 
; 26   :     stosb(disk, ' ', sizeof(volume->VolumeID));

	push	32					; 00000020H
	push	32					; 00000020H
	push	edi
	mov	DWORD PTR [edi+32], edi
	mov	DWORD PTR [edi+36], eax
	mov	DWORD PTR [edi+40], 3840		; 00000f00H
	mov	DWORD PTR [edi+44], 256			; 00000100H
	mov	DWORD PTR [edi+48], 4096		; 00001000H
	mov	DWORD PTR [edi+52], 262144		; 00040000H
	mov	DWORD PTR [edi+56], ebx
	mov	DWORD PTR [edi+60], ebx
	mov	DWORD PTR [edi+68], 64			; 00000040H
	mov	DWORD PTR [edi+72], ebx
	call	_stosb

; 27   :     movsb(disk, VolumeID, StrLen(VolumeID));

	push	DWORD PTR _VolumeID$[ebp]
	call	esi
	push	eax
	push	DWORD PTR _VolumeID$[ebp]
	push	edi
	call	_movsb

; 28   :     stosd(&disk[256], 'oooo', (4*KB-256)/4);

	push	960					; 000003c0H
	lea	esi, DWORD PTR [edi+256]
	push	1869573999				; 6f6f6f6fH
	push	esi
	call	_stosd

; 29   :     stosd(&disk[256], 'nnnn', 64/4);

	push	16					; 00000010H
	push	1852730990				; 6e6e6e6eH
	push	esi
	call	_stosd

; 30   :     disk[256] = 'v';

	mov	BYTE PTR [esi], 118			; 00000076H

; 31   : 
; 32   :     stosd(&disk[volume->NodeList], 0, (volume->FileData - volume->NodeList)/4);

	mov	ecx, DWORD PTR [edi+48]
	mov	eax, DWORD PTR [edi+52]
	sub	eax, ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	push	eax
	lea	eax, DWORD PTR [ecx+edi]
	push	ebx
	push	eax
	call	_stosd

; 33   :     stosd(&disk[volume->FileData], 'xxxx', (volume->DiskSize - volume->FileData)/4);

	mov	ecx, DWORD PTR [edi+52]
	add	esp, 64					; 00000040H
	mov	eax, DWORD PTR [edi+36]
	sub	eax, ecx
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	push	eax
	lea	eax, DWORD PTR [ecx+edi]
	push	2021161080				; 78787878H
	push	eax
	call	_stosd

; 34   :     return 1;

	xor	eax, eax
	add	esp, 12					; 0000000cH
	inc	eax
$LN5@DiskFormat:
	pop	esi
	pop	ebx
$LN3@DiskFormat:
	pop	edi

; 35   : }

	pop	ebp
	ret	0
_DiskFormat ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\ramdisk.c
_TEXT	SEGMENT
_blocks$1$ = -4						; size = 4
_DiskAlloc PROC
; _disk$ = ecx
; _size$ = edx

; 37   : int DiskAlloc(CDisk *disk, int size) {

	push	ecx
	push	ebx
	mov	ebx, ecx

; 38   :     if (!disk) return 0;

	test	ebx, ebx
	jne	SHORT $LN11@DiskAlloc
	xor	eax, eax
	jmp	SHORT $LN12@DiskAlloc
$LN11@DiskAlloc:

; 39   : 
; 40   :     size = (size + (4*KB-1)) & ~(4*KB-1);

	lea	eax, DWORD PTR [edx+4095]
	and	eax, -4096				; fffff000H

; 41   :     int n = size/(4*KB);

	cdq
	push	ebp

; 42   :     char *block = (char*)disk;
; 43   :     block = &block[disk->Geometry];

	mov	ebp, DWORD PTR [ebx+44]
	and	edx, 4095				; 00000fffH
	push	esi

; 44   :     int blocks = disk->Capacity;
; 45   : 
; 46   :     for (int i = disk->NextNode; i + n != disk->NextNode; i++) {

	mov	esi, DWORD PTR [ebx+68]
	add	ebp, ebx
	push	edi
	lea	edi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ebx+40]
	sar	edi, 12					; 0000000cH
	mov	DWORD PTR _blocks$1$[esp+20], eax
	lea	ecx, DWORD PTR [esi+edi]
	cmp	ecx, esi
	je	SHORT $LN24@DiskAlloc
$LL10@DiskAlloc:

; 47   :         i = i % blocks;

	mov	eax, esi
	cdq
	idiv	DWORD PTR _blocks$1$[esp+20]
	mov	esi, edx

; 48   :         if (block[i] == 'f') {

	lea	ecx, DWORD PTR [esi+ebp]
	cmp	BYTE PTR [ecx], 102			; 00000066H
	jne	SHORT $LN7@DiskAlloc

; 49   :             i = 0;

	xor	esi, esi
	jmp	SHORT $LN9@DiskAlloc
$LN7@DiskAlloc:

; 50   : 
; 51   :         } else for (int j = 0; j <= n; j++) {

	xor	eax, eax
	test	edi, edi
	js	SHORT $LN9@DiskAlloc
$LL5@DiskAlloc:

; 52   :             if (block[i+j] != 'o') break;

	cmp	BYTE PTR [ecx+eax], 111			; 0000006fH
	jne	SHORT $LN9@DiskAlloc

; 53   :             if (j == n) {

	cmp	eax, edi
	je	SHORT $LN17@DiskAlloc

; 50   : 
; 51   :         } else for (int j = 0; j <= n; j++) {

	inc	eax
	cmp	eax, edi
	jle	SHORT $LL5@DiskAlloc
$LN9@DiskAlloc:

; 44   :     int blocks = disk->Capacity;
; 45   : 
; 46   :     for (int i = disk->NextNode; i + n != disk->NextNode; i++) {

	inc	esi
	lea	eax, DWORD PTR [esi+edi]
	cmp	eax, DWORD PTR [ebx+68]
	jne	SHORT $LL10@DiskAlloc
$LN24@DiskAlloc:

; 57   :             }
; 58   :         }
; 59   :     }
; 60   :     return 0;

	xor	eax, eax
$LN25@DiskAlloc:
	pop	edi
	pop	esi
	pop	ebp
$LN12@DiskAlloc:
	pop	ebx

; 61   : }

	pop	ecx
	ret	0
$LN17@DiskAlloc:

; 54   :                 stosb(&block[i], 'x', n);

	push	edi
	lea	eax, DWORD PTR [esi+ebp]
	push	120					; 00000078H
	push	eax
	call	_stosb

; 55   :                 disk->NextNode = (i + n) % blocks;

	lea	eax, DWORD PTR [esi+edi]
	add	esp, 12					; 0000000cH
	cdq
	idiv	DWORD PTR _blocks$1$[esp+20]

; 56   :                 return i;

	mov	eax, esi
	mov	DWORD PTR [ebx+68], edx
	jmp	SHORT $LN25@DiskAlloc
_DiskAlloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\ramdisk.c
_TEXT	SEGMENT
_disk$ = 8						; size = 4
_path$ = 12						; size = 4
_DiskSearch PROC

; 78   :     char *base = (char*)disk;
; 79   :     INode *node = (INode*)&base[disk->NodeList];

	mov	eax, DWORD PTR _disk$[esp-4]
	push	esi

; 80   :     int n = BinarySearch((char*)node, disk->NodeCount, sizeof(INode), 16, path);

	push	DWORD PTR _path$[esp]
	mov	esi, DWORD PTR [eax+48]
	push	16					; 00000010H
	push	64					; 00000040H
	push	DWORD PTR [eax+56]
	add	esi, eax
	push	esi
	call	DWORD PTR __imp__BinarySearch
	add	esp, 20					; 00000014H

; 81   :     if (n < 0) return 0;

	test	eax, eax
	jns	SHORT $LN1@DiskSearch
	xor	eax, eax
	pop	esi

; 83   : }

	ret	0
$LN1@DiskSearch:

; 82   :     return &node[n];

	shl	eax, 6
	add	eax, esi
	pop	esi

; 83   : }

	ret	0
_DiskSearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\ramdisk.c
_TEXT	SEGMENT
_lba$1$ = -4						; size = 4
_len$1$ = 8						; size = 4
_disk$ = 8						; size = 4
_path$ = 12						; size = 4
_size$ = 16						; size = 4
_flag$ = 20						; size = 4
_DiskInsert PROC

; 85   : INode *DiskInsert(CDisk *disk, char *path, int size, char *flag) {

	push	ecx
	push	esi

; 86   :     char *base = (char*)disk;
; 87   :     INode *item = DiskSearch(disk, path);

	push	DWORD PTR _path$[esp+4]
	mov	esi, DWORD PTR _disk$[esp+8]
	push	esi
	call	_DiskSearch
	pop	ecx
	pop	ecx

; 88   :     if (item) return item; // FileNames must be unique, so just return the existing one

	test	eax, eax
	jne	$LN10@DiskInsert

; 89   :     if (size < 0) return 0; // Error("RamDisk.Create [fail] Negative file size! %s\n", path);

	cmp	DWORD PTR _size$[esp+4], eax
	jl	$LN10@DiskInsert
$LN8@DiskInsert:
	push	edi

; 90   :     if ((flag[0] != 's' && flag[0] != '-') || (flag[1] != 'r' && flag[1] != '-') ||
; 91   :         (flag[2] != 'w' && flag[2] != '-') || (flag[3] != 'x' && flag[3] != '-')) {

	mov	edi, DWORD PTR _flag$[esp+8]
	mov	al, BYTE PTR [edi]
	cmp	al, 115					; 00000073H
	je	SHORT $LN5@DiskInsert
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN6@DiskInsert
$LN5@DiskInsert:
	mov	al, BYTE PTR [edi+1]
	cmp	al, 114					; 00000072H
	je	SHORT $LN4@DiskInsert
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN6@DiskInsert
$LN4@DiskInsert:
	mov	al, BYTE PTR [edi+2]
	cmp	al, 119					; 00000077H
	je	SHORT $LN3@DiskInsert
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN6@DiskInsert
$LN3@DiskInsert:
	mov	al, BYTE PTR [edi+3]
	cmp	al, 120					; 00000078H
	je	SHORT $LN7@DiskInsert
	cmp	al, 45					; 0000002dH
	je	SHORT $LN7@DiskInsert
$LN6@DiskInsert:

; 92   :         return 0; // Error("RamDisk.Create [fail] Invalid file permissions! %s (%s)\n", path, flag);

	xor	eax, eax
	jmp	$LN12@DiskInsert
$LN7@DiskInsert:
	push	ebx

; 93   :     }
; 94   : 
; 95   :     INode *node = (INode*)&base[disk->NodeList];
; 96   :     item = &node[disk->NodeCount];

	mov	ebx, DWORD PTR [esi+56]
	push	ebp
	mov	ebp, DWORD PTR [esi+48]

; 97   : 
; 98   :     int len = StrLen(path);

	push	DWORD PTR _path$[esp+16]
	add	ebp, esi
	shl	ebx, 6
	add	ebx, ebp
	call	DWORD PTR __imp__StrLen
	mov	DWORD PTR _len$1$[esp+20], eax
	pop	ecx

; 99   :     if (len > 48-1) return 0; // Error("RamDisk.Create [fail] File name is too long! %s > 47 characters\n", path);

	cmp	eax, 47					; 0000002fH
	jg	SHORT $LN15@DiskInsert

; 100  : 
; 101  :     int lba = DiskAlloc(disk, size);

	mov	edx, DWORD PTR _size$[esp+16]
	mov	ecx, esi
	call	_DiskAlloc
	mov	DWORD PTR _lba$1$[esp+20], eax

; 102  :     if (!lba) return 0; // Error("RamDisk.Create [fail] Out of disk space! %s\n", path);

	test	eax, eax
	jne	SHORT $LN1@DiskInsert
$LN15@DiskInsert:
	xor	eax, eax
	jmp	SHORT $LN13@DiskInsert
$LN1@DiskInsert:

; 103  : 
; 104  :     stosb(item, 0, sizeof(INode));

	push	64					; 00000040H
	push	0
	push	ebx
	call	_stosb

; 105  :     movsb(&item->FileName, path, len);

	push	DWORD PTR _len$1$[esp+28]
	lea	eax, DWORD PTR [ebx+16]
	push	DWORD PTR _path$[esp+32]
	push	eax
	call	_movsb

; 106  :     movsb(&item->FileFlag, flag, 4);

	push	4
	push	edi
	push	ebx
	call	_movsb

; 107  :     item->FileSize = size;

	mov	eax, DWORD PTR _size$[esp+52]

; 108  :     item->FileData = lba*4*KB;

	mov	ecx, DWORD PTR _lba$1$[esp+56]

; 109  :     item->CheckSum = 0;

	and	DWORD PTR [ebx+12], 0
	mov	DWORD PTR [ebx+8], eax

; 110  : 
; 111  :     char *data = &base[disk->FileData + lba*4*KB];
; 112  :     int dspace = (size+(4*KB-1)) / (4*KB);

	add	eax, 4095				; 00000fffH
	cdq
	and	edx, 4095				; 00000fffH
	shl	ecx, 12					; 0000000cH
	add	eax, edx
	mov	DWORD PTR [ebx+4], ecx
	sar	eax, 12					; 0000000cH

; 113  :     stosd(data, 'xxxx', dspace/4);

	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	push	eax
	mov	eax, DWORD PTR [esi+52]
	add	eax, ecx
	add	eax, esi
	push	2021161080				; 78787878H
	push	eax
	call	_stosd

; 114  : 
; 115  :     disk->NodeCount++;

	inc	DWORD PTR [esi+56]

; 116  :     BubbleSort((char*)node, disk->NodeCount, sizeof(INode), 16);

	push	16					; 00000010H
	push	64					; 00000040H
	push	DWORD PTR [esi+56]
	push	ebp
	call	DWORD PTR __imp__BubbleSort
	add	esp, 64					; 00000040H

; 117  :     return item;

	mov	eax, ebx
$LN13@DiskInsert:
	pop	ebp
	pop	ebx
$LN12@DiskInsert:
	pop	edi
$LN10@DiskInsert:
	pop	esi

; 118  : }

	pop	ecx
	ret	0
_DiskInsert ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\ramdisk.c
_TEXT	SEGMENT
_disk$ = 8						; size = 4
_path$ = 12						; size = 4
_DiskRemove PROC

; 121  :     char *base = (char*)disk;
; 122  :     INode *item = DiskSearch(disk, path);

	push	DWORD PTR _path$[esp-4]
	mov	eax, DWORD PTR _disk$[esp]
	push	eax
	call	_DiskSearch
	pop	ecx
	pop	ecx
	mov	ecx, eax

; 123  :     if (!item) return 0; // Error("RamDisk.Delete [fail] File not found! %s\n", path);

	test	ecx, ecx
	jne	SHORT $LN1@DiskRemove

; 139  : }

	ret	0
$LN1@DiskRemove:

; 124  : 
; 125  :     int s = (int)item->FileData;
; 126  :     int f = (int)item->FileSize + s;
; 127  : 
; 128  :     disk->NodeCount--;

	mov	eax, DWORD PTR _disk$[esp-4]
	push	ebx
	mov	ebx, DWORD PTR [ecx+4]
	push	ebp
	push	esi

; 129  :     INode *node = (INode*)&base[disk->NodeList];

	mov	esi, DWORD PTR [eax+48]
	push	edi
	mov	edi, DWORD PTR [ecx+8]
	add	esi, eax
	add	edi, ebx
	dec	DWORD PTR [eax+56]
	mov	ebp, DWORD PTR [eax+56]

; 130  :     char *src = (char*)item;
; 131  :     char *trg = (char*)&node[disk->NodeCount];
; 132  :     Swap(trg, src, sizeof(INode));

	push	64					; 00000040H
	shl	ebp, 6
	push	ecx
	add	ebp, esi
	push	ebp
	call	DWORD PTR __imp__Swap

; 133  :     BubbleSort((char*)node, disk->NodeCount, sizeof(INode), 16);

	mov	eax, DWORD PTR _disk$[esp+24]
	push	16					; 00000010H
	push	64					; 00000040H
	push	DWORD PTR [eax+56]
	push	esi
	call	DWORD PTR __imp__BubbleSort

; 134  : 
; 135  :     char *block = &base[disk->Geometry];
; 136  :     stosb(&block[s/(4*KB)], 'o', (f-s)/(4*KB));

	sub	edi, ebx
	mov	ecx, 4095				; 00000fffH
	mov	eax, edi
	cdq
	and	edx, ecx
	add	eax, edx
	sar	eax, 12					; 0000000cH
	push	eax
	mov	eax, ebx
	cdq
	and	edx, ecx
	mov	ecx, DWORD PTR _disk$[esp+44]
	add	eax, edx
	sar	eax, 12					; 0000000cH
	push	111					; 0000006fH
	add	eax, DWORD PTR [ecx+44]
	add	eax, ecx
	push	eax
	call	_stosb

; 137  :     stosd(trg, 0, sizeof(INode)/4);

	push	16					; 00000010H
	push	0
	push	ebp
	call	_stosd
	add	esp, 52					; 00000034H

; 138  :     return 1;

	xor	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 139  : }

	ret	0
_DiskRemove ENDP
_TEXT	ENDS
END
