; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\BootLoad\BootLoad.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_bootload
PUBLIC	_BootLoad
_bootload DD	FLAT:_IBootLoad_Grub
	DD	FLAT:_IBootLoad_Boot
	DD	FLAT:_IBootLoad_Prepare
	DD	FLAT:_IBootLoad_Enable
	DD	FLAT:_IBootLoad_Activate
_BootLoad DD	FLAT:_bootload
PUBLIC	_IBootLoad_Boot
PUBLIC	_IBootLoad_Activate
PUBLIC	_IBootLoad_Enable
PUBLIC	_IBootLoad_Prepare
PUBLIC	_IBootLoad_Grub
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\bootload.c
_TEXT	SEGMENT
_info$ = 8						; size = 4
_IBootLoad_Grub PROC

; 18   :     if (!info) return false;

	mov	ecx, DWORD PTR _info$[esp-4]
	test	ecx, ecx
	jne	SHORT $LN1@IBootLoad_
	xor	eax, eax

; 20   : }

	ret	0
$LN1@IBootLoad_:

; 19   :     return MultiBoot(info);

	jmp	_MultiBoot
_IBootLoad_Grub ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\bootload.c
_TEXT	SEGMENT
_prepare$ = 8						; size = 4
_owner$1$ = 12						; size = 4
_count$ = 12						; size = 4
_IBootLoad_Prepare PROC

; 22   : bool IBootLoad_Prepare(CInstaller *prepare, int count) {

	push	ebx

; 23   :     for (int i = 0; i < count; i++) {

	mov	ebx, DWORD PTR _count$[esp]
	push	ebp
	push	esi
	mov	esi, DWORD PTR _prepare$[esp+8]
	push	edi
	xor	edi, edi
	mov	ebp, edi
	test	ebx, ebx
	jle	SHORT $LN2@IBootLoad_
$LL8@IBootLoad_:

; 24   :         int owner = prepare[i].Name;

	mov	eax, DWORD PTR [esi+ebp*8]
	mov	DWORD PTR _owner$1$[esp+12], eax

; 25   :         u8 *base = Monitor->GetBase(owner);

	push	eax
	mov	eax, DWORD PTR _Monitor
	call	DWORD PTR [eax+24]

; 26   :         u32 size = Monitor->GetSize(owner);

	mov	ecx, DWORD PTR _Monitor
	mov	esi, eax
	push	DWORD PTR _owner$1$[esp+16]
	call	DWORD PTR [ecx+28]

; 27   :         bool status = prepare[i].Proc(base, size);

	push	eax
	push	esi
	mov	esi, DWORD PTR _prepare$[esp+28]
	call	DWORD PTR [esi+ebp*8+4]
	add	esp, 16					; 00000010H

; 28   : #ifndef OPTIMIZED
; 29   :         u64 totext = (u64)owner;
; 30   :         if (status) Logger(" Installing %s ... OK\n", &totext);
; 31   :         else Logger(" Installing %s ... Failed\n", &totext);
; 32   : #endif
; 33   :         if (!status) return false;

	test	eax, eax
	je	SHORT $LN13@IBootLoad_

; 34   :         Monitor->Protect(owner);

	mov	eax, DWORD PTR _Monitor
	push	DWORD PTR _owner$1$[esp+12]
	call	DWORD PTR [eax+20]
	inc	ebp
	pop	ecx
	cmp	ebp, ebx
	jl	SHORT $LL8@IBootLoad_

; 35   :     }
; 36   : 
; 37   :     for (int i = 0; i < count; i++) {

	test	ebx, ebx
	jle	SHORT $LN2@IBootLoad_
$LL4@IBootLoad_:

; 38   :         bool status = Monitor->Verify(prepare[i].Name);

	mov	eax, DWORD PTR _Monitor
	push	DWORD PTR [esi+edi*8]
	call	DWORD PTR [eax+16]
	pop	ecx

; 39   :         if (!status) return false;

	test	eax, eax
	je	SHORT $LN13@IBootLoad_

; 35   :     }
; 36   : 
; 37   :     for (int i = 0; i < count; i++) {

	inc	edi
	cmp	edi, ebx
	jl	SHORT $LL4@IBootLoad_
$LN2@IBootLoad_:

; 40   :     }
; 41   :     return true;

	xor	eax, eax
	inc	eax
$LN9@IBootLoad_:

; 42   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN13@IBootLoad_:

; 28   : #ifndef OPTIMIZED
; 29   :         u64 totext = (u64)owner;
; 30   :         if (status) Logger(" Installing %s ... OK\n", &totext);
; 31   :         else Logger(" Installing %s ... Failed\n", &totext);
; 32   : #endif
; 33   :         if (!status) return false;

	xor	eax, eax
	jmp	SHORT $LN9@IBootLoad_
_IBootLoad_Prepare ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\bootload.c
_TEXT	SEGMENT
_enable$ = 8						; size = 4
_count$ = 12						; size = 4
_IBootLoad_Enable PROC

; 44   : bool IBootLoad_Enable(CInstaller *enable, int count) {

	push	ebx
	push	ebp
	push	esi
	push	edi

; 45   :     for (int i = 0; i < count; i++) {

	xor	edi, edi
	cmp	DWORD PTR _count$[esp+12], edi
	jle	SHORT $LN2@IBootLoad_
	mov	ebp, DWORD PTR _enable$[esp+12]
$LL4@IBootLoad_:

; 46   :         int owner = enable[i].Name;
; 47   :         u8 *base = Monitor->GetBase(owner);

	mov	eax, DWORD PTR _Monitor
	mov	ebx, DWORD PTR [ebp+edi*8]
	push	ebx
	call	DWORD PTR [eax+24]

; 48   :         u32 size = Monitor->GetSize(owner);

	mov	ecx, DWORD PTR _Monitor
	mov	esi, eax
	push	ebx
	call	DWORD PTR [ecx+28]

; 49   :         bool status = enable[i].Proc(base, size);

	push	eax
	push	esi
	call	DWORD PTR [ebp+edi*8+4]
	add	esp, 16					; 00000010H

; 50   : 
; 51   : #ifndef OPTIMIZED
; 52   :         u64 totext = (u64)owner;
; 53   :         if (status) Logger(" Enabling   %s ... OK\n", &totext);
; 54   :         else Logger(" Enabling   %s ... Failed\n", &totext);
; 55   : #endif
; 56   :         if (!status) return false;

	test	eax, eax
	je	SHORT $LN8@IBootLoad_

; 57   :         Monitor->Protect(owner);

	mov	eax, DWORD PTR _Monitor
	push	ebx
	call	DWORD PTR [eax+20]
	inc	edi
	pop	ecx
	cmp	edi, DWORD PTR _count$[esp+12]
	jl	SHORT $LL4@IBootLoad_
$LN2@IBootLoad_:

; 58   :     }
; 59   :     return true;

	xor	eax, eax
	inc	eax
$LN5@IBootLoad_:

; 60   : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	ret	0
$LN8@IBootLoad_:

; 50   : 
; 51   : #ifndef OPTIMIZED
; 52   :         u64 totext = (u64)owner;
; 53   :         if (status) Logger(" Enabling   %s ... OK\n", &totext);
; 54   :         else Logger(" Enabling   %s ... Failed\n", &totext);
; 55   : #endif
; 56   :         if (!status) return false;

	xor	eax, eax
	jmp	SHORT $LN5@IBootLoad_
_IBootLoad_Enable ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\bootload.c
_TEXT	SEGMENT
_IBootLoad_Activate PROC

; 63   :     if (!EnableSysCalls()) return false;

	call	_EnableSysCalls
	test	eax, eax
	jne	SHORT $LN5@IBootLoad_
$LN8@IBootLoad_:
	xor	eax, eax

; 68   :     return true;
; 69   : }

	ret	0
$LN5@IBootLoad_:

; 64   :     if (!Exception->Install()) return false;

	mov	eax, DWORD PTR _Exception
	call	DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN8@IBootLoad_

; 65   :     if (!EnablePs2()) return false;

	call	_EnablePs2
	test	eax, eax
	je	SHORT $LN8@IBootLoad_

; 66   :     if (!RemapPic()) return false;

	call	_RemapPic
	test	eax, eax
	je	SHORT $LN8@IBootLoad_

; 67   :     if (!EnableFpu()) return false;

	call	_EnableFpu
	neg	eax
	sbb	eax, eax
	neg	eax

; 68   :     return true;
; 69   : }

	ret	0
_IBootLoad_Activate ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\bootload\bootload.c
_TEXT	SEGMENT
_grub$ = 8						; size = 4
_IBootLoad_Boot PROC

; 72   :     return true;

	xor	eax, eax
	inc	eax

; 73   : }

	ret	0
_IBootLoad_Boot ENDP
_TEXT	ENDS
END
