; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\Thread\Process\Environment.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_04GGAEFGO@PIPE?$AA@			; `string'
PUBLIC	??_C@_04LNILAHFO@EVTS?$AA@			; `string'
PUBLIC	??_C@_04LOGAKCND@WINS?$AA@			; `string'
PUBLIC	??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@		; `string'
PUBLIC	??_C@_0BM@NGAFGNHL@?5Peb?4CommandLine?5?$DN?5?$CI?$CFX?$CJ?5?$CFs?6?$AA@ ; `string'
EXTRN	__imp__Format:PROC
;	COMDAT ??_C@_0BM@NGAFGNHL@?5Peb?4CommandLine?5?$DN?5?$CI?$CFX?$CJ?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BM@NGAFGNHL@?5Peb?4CommandLine?5?$DN?5?$CI?$CFX?$CJ?5?$CFs?6?$AA@ DB ' '
	DB	'Peb.CommandLine = (%X) %s', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
CONST	SEGMENT
??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@ DB '%s %s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04LOGAKCND@WINS?$AA@
CONST	SEGMENT
??_C@_04LOGAKCND@WINS?$AA@ DB 'WINS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04LNILAHFO@EVTS?$AA@
CONST	SEGMENT
??_C@_04LNILAHFO@EVTS?$AA@ DB 'EVTS', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04GGAEFGO@PIPE?$AA@
CONST	SEGMENT
??_C@_04GGAEFGO@PIPE?$AA@ DB 'PIPE', 00H		; `string'
PUBLIC	_IEnvironment_SetUp
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\thread\process\environment.c
_TEXT	SEGMENT
_path$ = 8						; size = 4
_args$ = 12						; size = 4
_IEnvironment_SetUp PROC
; _pcb$ = ecx
; _base$ = edx

; 19   : CPcb *IEnvironment_SetUp(CPcb *pcb, char *base, char *path, char *args) {

	push	ebx
	mov	ebx, ecx
	push	ebp

; 20   :     (int)pcb->Binary  += (int)base;
; 21   :     (int)pcb->AppMain += (int)base;
; 22   :     (int)pcb->Heap    += (int)base;
; 23   :     (int)pcb->Stack   += (int)base;
; 24   :     (int)pcb->Peb     += (int)base;

	add	DWORD PTR [ebx+20], edx
	add	DWORD PTR [ebx+8], edx
	add	DWORD PTR [ebx+4], edx
	add	DWORD PTR [ebx+12], edx
	add	DWORD PTR [ebx+16], edx
	mov	ebp, DWORD PTR [ebx+20]

; 25   :     (int)pcb->MemMap  += (int)base;

	add	DWORD PTR [ebx+24], edx

; 26   :     (int)pcb->Pipes   += (int)base;

	add	DWORD PTR [ebx+28], edx

; 27   :     (int)pcb->Events  += (int)base;

	add	DWORD PTR [ebx+32], edx

; 28   :     (int)pcb->Windows += (int)base;

	add	DWORD PTR [ebx+36], edx

; 29   :     (int)pcb->Screen  += (int)base;

	add	DWORD PTR [ebx+40], edx

; 30   :     char *seg = (char*)pcb->Peb;
; 31   :     if (!seg) return 0;

	test	ebp, ebp
	jne	SHORT $LN1@IEnvironme
	xor	eax, eax
	jmp	$LN2@IEnvironme
$LN1@IEnvironme:
	push	esi
	push	edi

; 32   : 
; 33   :     CPeb *peb = (CPeb*)&seg[0x00000000];
; 34   :     CPcb *raw = (CPcb*)&seg[0x00000100];
; 35   :     movsd(raw, pcb, sizeof(CPcb)/4);

	push	12					; 0000000cH
	lea	edi, DWORD PTR [ebp+256]
	push	ebx
	push	edi
	call	_movsd

; 36   : 
; 37   :     peb->Canvas     = (CCanvas*)&seg[0x00000200];
; 38   :     peb->HeapPool   = (CPool  *)&seg[0x00000300 + 0*align(sizeof(CPool), 64)];

	lea	eax, DWORD PTR [ebp+768]
	mov	DWORD PTR [ebp], eax
	lea	esi, DWORD PTR [ebp+512]

; 39   :     peb->PipePool   = (CPool  *)&seg[0x00000300 + 1*align(sizeof(CPool), 64)];

	lea	eax, DWORD PTR [ebp+832]
	mov	DWORD PTR [ebp+16], esi
	mov	DWORD PTR [ebp+4], eax

; 40   :     peb->EventPool  = (CPool  *)&seg[0x00000300 + 2*align(sizeof(CPool), 64)];

	lea	eax, DWORD PTR [ebp+896]
	mov	DWORD PTR [ebp+8], eax

; 41   :     peb->WindowPool = (CPool  *)&seg[0x00000300 + 3*align(sizeof(CPool), 64)];

	lea	eax, DWORD PTR [ebp+960]
	mov	DWORD PTR [ebp+12], eax

; 42   :     peb->Pages      = (int    *)&seg[0x00001000];

	lea	eax, DWORD PTR [ebp+4096]
	mov	DWORD PTR [ebp+24], eax

; 43   :     peb->Stack0     = (int    *)&seg[0x0007F000];

	lea	eax, DWORD PTR [ebp+520192]
	mov	DWORD PTR [ebp+28], eax

; 44   : 
; 45   :     char *pipes   = &seg[0x0007F800];
; 46   :     char *events  = &seg[0x00080000];
; 47   :     char *windows = &seg[0x000C0000];
; 48   : 
; 49   :     CCanvas *canvas  = peb->Canvas;
; 50   :     canvas->ResX     = Vesa->ResX();

	mov	eax, DWORD PTR _Vesa
	call	DWORD PTR [eax]
	movzx	eax, ax
	mov	DWORD PTR [esi+48], eax

; 51   :     canvas->ResY     = Vesa->ResY();

	mov	eax, DWORD PTR _Vesa
	call	DWORD PTR [eax+4]
	movzx	eax, ax
	mov	DWORD PTR [esi+52], eax

; 52   :     canvas->ScanLine = Vesa->Bits()*peb->Canvas->ResX/8;

	mov	eax, DWORD PTR _Vesa
	call	DWORD PTR [eax+8]
	movzx	ecx, ax
	mov	eax, DWORD PTR [ebp+16]

; 53   :     canvas->Disp     = (char*)pcb->Screen;
; 54   :     canvas->Draw     = &canvas->Disp[canvas->ResY*canvas->ScanLine];
; 55   :     canvas->Peb      = peb;
; 56   :     canvas->Pcb      = raw;
; 57   :     stosd(canvas->Disp, 0, 8*MB/4);

	push	2097152					; 00200000H
	push	0
	imul	ecx, DWORD PTR [eax+48]
	mov	eax, ecx
	cdq
	and	edx, 7
	add	eax, edx
	sar	eax, 3
	mov	DWORD PTR [esi+36], eax
	mov	ecx, DWORD PTR [ebx+40]
	imul	eax, DWORD PTR [esi+52]
	push	ecx
	mov	DWORD PTR [esi+28], ecx
	mov	DWORD PTR [esi], ebp
	mov	DWORD PTR [esi+4], edi
	add	eax, ecx
	mov	DWORD PTR [esi+32], eax
	call	_stosd

; 58   : 
; 59   :     int pipesize  = 4*KB;
; 60   :     int pipecount = 1*MB/pipesize;
; 61   :     int evtsize  = align(sizeof(CEvent), 64);
; 62   :     int evtcount = 1*MB/evtsize;
; 63   :     int winsize  = align(sizeof(CWindow), 64);
; 64   :     int wincount = 4*MB/winsize;
; 65   : 
; 66   :     Pool->CreateMeta(peb->HeapPool, 1*MB, 4*KB, 0, 0, "HEAP");

	mov	eax, DWORD PTR _Pool
	mov	esi, 4096				; 00001000H
	push	OFFSET ??_C@_04DGHHAJMG@HEAP?$AA@
	push	0
	push	0
	push	esi
	push	1048576					; 00100000H
	push	DWORD PTR [ebp]
	call	DWORD PTR [eax]

; 67   :     Pool->CreateMeta(peb->PipePool, pipecount, 4*KB, pipes, (char*)pcb->Pipes, "PIPE");

	push	OFFSET ??_C@_04GGAEFGO@PIPE?$AA@
	push	DWORD PTR [ebx+28]
	lea	eax, DWORD PTR [ebp+522240]
	push	eax
	mov	eax, DWORD PTR _Pool
	push	esi
	push	256					; 00000100H
	push	DWORD PTR [ebp+4]
	call	DWORD PTR [eax]
	add	esp, 72					; 00000048H
	lea	eax, DWORD PTR [ebp+524288]

; 68   :     Pool->CreateMeta(peb->EventPool, evtcount, evtsize, events, (char*)pcb->Events, "EVTS");

	push	OFFSET ??_C@_04LNILAHFO@EVTS?$AA@
	push	DWORD PTR [ebx+32]
	push	eax
	mov	eax, DWORD PTR _Pool
	push	128					; 00000080H
	push	8192					; 00002000H
	push	DWORD PTR [ebp+8]
	call	DWORD PTR [eax]

; 69   :     Pool->CreateMeta(peb->WindowPool, wincount, winsize, windows, (char*)pcb->Windows, "WINS");

	push	OFFSET ??_C@_04LOGAKCND@WINS?$AA@
	push	DWORD PTR [ebx+36]
	lea	eax, DWORD PTR [ebp+786432]
	push	eax
	mov	eax, DWORD PTR _Pool
	push	576					; 00000240H
	push	7281					; 00001c71H
	push	DWORD PTR [ebp+12]
	call	DWORD PTR [eax]

; 70   : 
; 71   :     peb->HeapPool->Data = (char*)pcb->Heap;

	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebx+12]

; 72   :     peb->HeapPool->Node = (char*)pcb->MemMap;
; 73   :     peb->HeapPool->Next = 0;
; 74   : 
; 75   :     int count = (pcb->Stack-pcb->Heap) / (4*KB);
; 76   :     stosd(&peb->HeapPool->Node[0], '----', 1*MB/4);

	push	262144					; 00040000H
	push	757935405				; 2d2d2d2dH
	mov	DWORD PTR [ecx+12], eax
	mov	ecx, DWORD PTR [ebp]
	mov	eax, DWORD PTR [ebx+24]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR [ebp]
	and	DWORD PTR [eax+24], 0
	mov	eax, DWORD PTR [ebx+16]
	sub	eax, DWORD PTR [ebx+12]
	cdq
	and	edx, 4095				; 00000fffH
	lea	esi, DWORD PTR [edx+eax]
	mov	eax, DWORD PTR [ebp]
	sar	esi, 12					; 0000000cH
	push	DWORD PTR [eax+8]
	call	_stosd

; 77   :     stosd(&peb->HeapPool->Node[0], 'oooo', (count+3)/4);

	lea	eax, DWORD PTR [esi+3]
	cdq
	and	edx, 3
	add	eax, edx
	sar	eax, 2
	push	eax
	mov	eax, DWORD PTR [ebp]
	push	1869573999				; 6f6f6f6fH
	push	DWORD PTR [eax+8]
	call	_stosd

; 78   : 
; 79   :     char *pipe = peb->PipePool->Data;

	mov	eax, DWORD PTR [ebp+4]
	add	esp, 72					; 00000048H
	mov	esi, DWORD PTR [eax+12]

; 80   :     int cmd = Pool->Alloc(peb->PipePool);

	push	eax
	mov	eax, DWORD PTR _Pool
	call	DWORD PTR [eax+8]

; 81   :     peb->CommandLine = &pipe[cmd*4*KB];

	shl	eax, 12					; 0000000cH
	add	eax, esi

; 82   :     stosd(peb->CommandLine, 0, 4*KB/4);

	mov	DWORD PTR [esp], 1024			; 00000400H
	push	0
	push	eax
	mov	DWORD PTR [ebp+48], eax
	call	_stosd

; 83   :     Format(peb->CommandLine, "%s %s", path, args);

	push	DWORD PTR _args$[esp+24]
	push	DWORD PTR _path$[esp+28]
	push	OFFSET ??_C@_05DNIIFBMG@?$CFs?5?$CFs?$AA@
	push	DWORD PTR [ebp+48]
	call	DWORD PTR __imp__Format

; 84   :     Debug(" Peb.CommandLine = (%X) %s\n", peb->CommandLine, peb->CommandLine);

	push	DWORD PTR [ebp+48]
	push	DWORD PTR [ebp+48]
	push	OFFSET ??_C@_0BM@NGAFGNHL@?5Peb?4CommandLine?5?$DN?5?$CI?$CFX?$CJ?5?$CFs?6?$AA@
	call	_Debug
	add	esp, 40					; 00000028H

; 85   :     return raw;

	mov	eax, edi
	pop	edi
	pop	esi
$LN2@IEnvironme:

; 86   : }

	pop	ebp
	pop	ebx
	ret	0
_IEnvironment_SetUp ENDP
_TEXT	ENDS
END
