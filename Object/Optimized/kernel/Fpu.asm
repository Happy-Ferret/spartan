; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\FYP\develop\spartan\Source\Kernel\BootLoad\Intel\Fpu.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_fpu
PUBLIC	_sse
PUBLIC	_tsc
PUBLIC	_x87
PUBLIC	_mmx
PUBLIC	_simd
EXTRN	_cpuid:PROC
EXTRN	_set_cr0:PROC
EXTRN	_get_cr0:PROC
EXTRN	_set_cr4:PROC
EXTRN	_fldcw:PROC
EXTRN	_get_cr4:PROC
EXTRN	_ldmxcsr:PROC
EXTRN	_fnstsw:PROC
EXTRN	_fninit:PROC
_fpu	DD	01H DUP (?)
_sse	DD	01H DUP (?)
_tsc	DD	01H DUP (?)
_mmx	DD	01H DUP (?)
_BSS	ENDS
_x87	DB	07fH, 0fH, 0ffH, 0ffH, 00H, 00H, 0ffH, 0ffH, 0ffH, 0ffH, 0ffH
	DB	0ffH, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 0ffH, 0ffH, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 'xxxxxxxxxxxxxxxxxxxx'
_simd	DB	07fH, 0fH, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
	DB	0ffH, 00H, 00H, 0ffH, 0ffH, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
PUBLIC	_TscEnable
PUBLIC	_FpuEnable
PUBLIC	_SseEnable
PUBLIC	_EnableFpu
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\bootload\intel\fpu.c
_TEXT	SEGMENT
_EnableFpu PROC

; 69   :     FpuEnable();

	call	_FpuEnable

; 70   :     SseEnable();

	call	_SseEnable

; 71   :     TscEnable();

	call	_TscEnable

; 72   : 
; 73   :     Logger(" [info] CPU Features %s %s %s %s\n",
; 74   :         fpu ? "FPU" : "",
; 75   :         mmx ? "MMX" : "",
; 76   :         sse ? "SSE" : "",
; 77   :         tsc ? "TSC" : "");
; 78   :     return true;

	xor	eax, eax
	inc	eax

; 79   : }

	ret	0
_EnableFpu ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\bootload\intel\fpu.c
_TEXT	SEGMENT
_reg$ = -20						; size = 16
_mxcsr$1 = -4						; size = 4
_SseEnable PROC

; 8    : bool SseEnable(void) {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 9    :     u32 reg[4];
; 10   :     cpuid(0x000000001, reg);

	lea	eax, DWORD PTR _reg$[ebp]
	push	eax
	push	1
	call	_cpuid
	pop	ecx
	pop	ecx

; 11   :     mmx = ((reg[3] & (1 << 23)) != 0); // CPUID page 1, in EDX bit 23

	mov	ecx, DWORD PTR _reg$[ebp+12]
	mov	eax, ecx
	shr	eax, 23					; 00000017H
	and	eax, 1

; 12   :     sse = ((reg[3] & (1 << 25)) != 0); // CPUID page 1, in EDX bit 25

	shr	ecx, 25					; 00000019H
	and	ecx, 1
	mov	DWORD PTR _mmx, eax
	mov	DWORD PTR _sse, ecx

; 13   :     if (sse) {

	je	SHORT $LN1@SseEnable

; 14   :         u32 cr4 = get_cr4() | CR4_OSFXSR|CR4_OSXMMEXCPT;

	call	_get_cr4
	or	eax, 1536				; 00000600H

; 15   :         set_cr4(cr4);

	push	eax
	call	_set_cr4

; 16   :         // when CR4.OSFXSR     = 0 fnsave and frstor save x87 FPU and MMX state
; 17   :         // when CR4.OSFXSR     = 1 fxsave and fxrstor save SSE XMM state
; 18   :         // when CR4.OSXMMEXCPT = 0 SIMD errors generate invalid opcode exceptions
; 19   :         // when CR4.OSXMMEXCPT = 1 SIMD errors generate SIMD FPU exceptions
; 20   : 
; 21   :         u32 mxcsr = 0;
; 22   :         mxcsr |= MXCSR_FZ | MXCSR_RC;
; 23   :         mxcsr |= (MXCSR_IM|MXCSR_DM|MXCSR_ZM|MXCSR_OM|MXCSR_UM|MXCSR_PM);
; 24   :         ldmxcsr(&mxcsr);

	lea	eax, DWORD PTR _mxcsr$1[ebp]
	mov	DWORD PTR _mxcsr$1[ebp], 65408		; 0000ff80H
	push	eax
	call	_ldmxcsr
	pop	ecx
	pop	ecx
	mov	ecx, DWORD PTR _sse
$LN1@SseEnable:

; 25   :     }
; 26   :     return sse;

	mov	eax, ecx

; 27   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_SseEnable ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\bootload\intel\fpu.c
_TEXT	SEGMENT
_fpusw$ = -4						; size = 2
_FpuEnable PROC

; 29   : export bool FpuEnable(void) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 30   :     u32 cr0 = (get_cr0() & ~(CR0_EM|CR0_MP)) | (CR0_NE);

	call	_get_cr0
	and	eax, -7					; fffffff9H
	or	eax, 32					; 00000020H

; 31   :     set_cr0(cr0);

	push	eax
	call	_set_cr0

; 32   :     // when CR0.EM = 0 (Emulation) FPU is an internal to the processor and floating point opcodes may be executed
; 33   :     // when CR0.EM = 1 (Emulation) FPU is an external device and executing any floating point opcodes raises an exception
; 34   :     // when CR0.MP = 0 (Monitor FPU) FWAIT ignored
; 35   :     // when CR0.MP = 1 (Monitor FPU) FWAIT generated device not available exception
; 36   :     // when CR0.NE = 0 (Numeric Error) external FPU errors (raises IRQs)
; 37   :     // when CR0.NE = 1 (Numeric Error) internal FPU method (exceptions which are much faster)
; 38   : 
; 39   :     fninit(); // initialize floating point unit

	call	_fninit

; 40   :     u16 fpusw = 'xx';
; 41   :     fnstsw(&fpusw);         // get the status word

	lea	eax, DWORD PTR _fpusw$[ebp]
	mov	esi, 30840				; 00007878H
	push	eax
	mov	DWORD PTR _fpusw$[ebp], esi
	call	_fnstsw

; 42   :     fpu = (fpusw != 'xx');  // sanity check

	xor	eax, eax
	cmp	WORD PTR _fpusw$[ebp], si
	pop	ecx
	setne	al
	mov	DWORD PTR _fpu, eax
	pop	ecx
	pop	esi

; 43   :     if (!fpu) return false;

	test	eax, eax
	je	SHORT $LN2@FpuEnable
$LN1@FpuEnable:

; 44   : 
; 45   :     u16 fpucw = FPUCW_PC_EXTENDED
; 46   :               | FPUCW_RC_TONEAREST // |FPUCW_RC_TOZERO|FPUCW_RC_ROUNDDOWN|FPUCW_RC_ROUNDUP
; 47   :               | FPUCW_IM | FPUCW_DM | FPUCW_ZM | FPUCW_OM
; 48   :               | FPUCW_UM | FPUCW_PM | 0x40;
; 49   :     fldcw(fpucw);

	push	895					; 0000037fH
	call	_fldcw

; 50   :     return true;

	xor	eax, eax
	pop	ecx
	inc	eax
$LN2@FpuEnable:

; 51   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_FpuEnable ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\bootload\intel\fpu.c
_TEXT	SEGMENT
_TscEnable PROC

; 54   :     u32 cr4 = get_cr4();

	call	_get_cr4

; 55   :     cr4 = cr4 & ~CR4_TSD; // enable user mode RDTSC
; 56   :     cr4 = cr4 & ~CR4_PCE; // enable user mode RDPMC

	and	eax, -261				; fffffefbH

; 57   :     set_cr4(cr4);

	push	eax
	call	_set_cr4

; 58   : 
; 59   :     // when CR4.TSD = 0 RDTSC may only be executed from ring0
; 60   :     // when CR4.TSD = 1 RDTSC may be executed from user mode
; 61   :     // when CR4.PCE = 0 RDPMC may be executed from user mode
; 62   :     // when CR4.PCE = 1 RDPMC may only be executed from ring0
; 63   :     tsc = true;

	xor	eax, eax
	inc	eax
	pop	ecx
	mov	DWORD PTR _tsc, eax

; 64   :     return true;
; 65   : }

	ret	0
_TscEnable ENDP
_TEXT	ENDS
END
