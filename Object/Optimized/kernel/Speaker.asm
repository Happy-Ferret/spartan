; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\FYP\develop\spartan\Source\Kernel\Device\Drivers\Speaker.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

_play	DD	01H
PUBLIC	_Speaker
PUBLIC	_ISpeaker_SetHerz
PUBLIC	_InstallSpeaker
PUBLIC	_EnableSpeaker
_pipe	DD	01H DUP (?)
_hz	DD	01H DUP (?)
_counter DW	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\drivers\speaker.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_EnableSpeaker PROC

; 61   :     Device->Latch(IRQ_PIT, Speaker);

	mov	eax, DWORD PTR _Device
	push	OFFSET _Speaker
	push	32					; 00000020H
	call	DWORD PTR [eax]
	pop	ecx

; 62   :     return true;

	xor	eax, eax
	pop	ecx
	inc	eax

; 63   : }

	ret	0
_EnableSpeaker ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\drivers\speaker.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallSpeaker PROC

; 53   :     pipe = (CPipe*)base;

	mov	ecx, DWORD PTR _base$[esp-4]

; 54   :     Pipe->Create(pipe, 1, 1); // 1 = Pid Shell

	push	1
	push	1
	mov	DWORD PTR _pipe, ecx
	push	ecx
	mov	ecx, DWORD PTR _Pipe
	call	DWORD PTR [ecx]

; 55   :     play = false;

	and	DWORD PTR _play, 0

; 56   :     hz = 0;
; 57   :     return true;

	xor	eax, eax
	and	DWORD PTR _hz, 0
	add	esp, 12					; 0000000cH
	inc	eax

; 58   : }

	ret	0
_InstallSpeaker ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\drivers\speaker.c
_TEXT	SEGMENT
_ISpeaker_SetHerz PROC
; _hertz$ = ecx

; 16   :     hz = hertz;

	mov	DWORD PTR _hz, ecx

; 17   :     if (!hz) hz = 1;

	test	ecx, ecx
	jne	SHORT $LN1@ISpeaker_S
	inc	ecx
	mov	DWORD PTR _hz, ecx
$LN1@ISpeaker_S:

; 18   :     counter = 1193180 / hz;

	xor	edx, edx
	mov	eax, 1193180				; 001234dcH
	div	ecx
	push	ebx

; 19   : 
; 20   :     // 10|11|011|0
; 21   :     outb(PIT_COMMAND, PIT_CH2|PIT_BOTH|PIT_SQWV);

	push	182					; 000000b6H
	push	67					; 00000043H
	mov	WORD PTR _counter, ax
	call	_outb

; 23   :     u8 hi = counter / 256;

	mov	ax, WORD PTR _counter
	mov	bl, ah
	movzx	eax, ax
	and	eax, -2147483393			; 800000ffH
	jns	SHORT $LN4@ISpeaker_S

; 22   :     u8 lo = counter % 256;

	dec	eax
	or	eax, -256				; ffffff00H
	inc	eax
$LN4@ISpeaker_S:

; 24   :     outb(PIT_TIMER2, lo);

	movzx	eax, al
	push	eax
	push	66					; 00000042H
	call	_outb

; 25   :     outb(PIT_TIMER2, hi);

	movzx	ecx, bl
	push	ecx
	push	66					; 00000042H
	call	_outb
	add	esp, 24					; 00000018H

; 26   :     return true;

	xor	eax, eax
	inc	eax
	pop	ebx

; 27   : }

	ret	0
_ISpeaker_SetHerz ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\drivers\speaker.c
_TEXT	SEGMENT
_err$ = 8						; size = 4
_esp$ = 12						; size = 4
_Speaker PROC

; 30   :     if (play) {

	cmp	DWORD PTR _play, 0
	je	SHORT $LN1@Speaker

; 31   :         char pcm = pipe->Pointer[pipe->Head % pipe->Capacity];

	push	esi
	push	edi
	mov	edi, DWORD PTR _pipe
	xor	edx, edx
	mov	esi, DWORD PTR [edi+24]
	mov	eax, esi
	div	DWORD PTR [edi+8]
	mov	eax, DWORD PTR [edi]
	mov	cl, BYTE PTR [edx+eax]

; 32   :         pipe->Head++;

	lea	eax, DWORD PTR [esi+1]

; 33   :         ISpeaker_SetHerz(pcm);

	movsx	ecx, cl
	mov	DWORD PTR [edi+24], eax
	call	_ISpeaker_SetHerz
	pop	edi
	pop	esi
$LN1@Speaker:

; 34   :     }
; 35   :     return esp;

	mov	eax, DWORD PTR _esp$[esp-4]

; 36   : }

	ret	0
_Speaker ENDP
_TEXT	ENDS
END
