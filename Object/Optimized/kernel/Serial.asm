; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\Device\Drivers\Serial.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_EnableCom
PUBLIC	_SerialCom2
PUBLIC	_SerialCom1
PUBLIC	_Serial
PUBLIC	_SerialPutb
PUBLIC	_EnableSerial
PUBLIC	_InstallCom1
PUBLIC	_InstallCom2
	ALIGN	4

_com2_recv DD	01H DUP (?)
_com1_send DD	01H DUP (?)
_com1_recv DD	01H DUP (?)
_com2_send DD	01H DUP (?)
_BSS	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallCom2 PROC

; 71   :     stosd(base, 'xxxx', size/4);

	mov	eax, DWORD PTR _size$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _base$[esp+4]
	shr	eax, 2
	push	eax
	push	2021161080				; 78787878H
	push	esi
	call	_stosd

; 72   : 
; 73   :     com2_recv = (CPipeAsync*)&base[0*KB];
; 74   :     Pipe->CreateAsync(com2_recv, nullptr, SerialPutb);

	mov	eax, DWORD PTR _Pipe
	mov	ebx, OFFSET _SerialPutb
	push	ebx
	push	0
	push	esi
	mov	DWORD PTR _com2_recv, esi
	call	DWORD PTR [eax+4]

; 75   :     com2_recv->Writer = (void*)SerialPutb;

	mov	eax, DWORD PTR _com2_recv

; 76   :     com2_recv->Lock = COM2;
; 77   : 
; 78   :     com2_send = (CPipeAsync*)&base[4*KB];
; 79   :     Pipe->CreateAsync(com2_send, SerialPutb, nullptr);

	push	0
	push	ebx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+4], 760			; 000002f8H
	lea	eax, DWORD PTR [esi+4096]
	mov	DWORD PTR _com2_send, eax
	push	eax
	mov	eax, DWORD PTR _Pipe
	call	DWORD PTR [eax+4]

; 80   :     com2_send->Reader = (void*)SerialPutb;

	mov	eax, DWORD PTR _com2_send
	add	esp, 36					; 00000024H
	mov	DWORD PTR [eax+16], ebx

; 81   :     com2_send->Lock = COM2;

	mov	DWORD PTR [eax+4], 760			; 000002f8H

; 82   :     return true;

	xor	eax, eax
	pop	esi
	inc	eax
	pop	ebx

; 83   : }

	ret	0
_InstallCom2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_InstallCom1 PROC

; 56   :     stosd(base, 'xxxx', size/4);

	mov	eax, DWORD PTR _size$[esp-4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR _base$[esp+4]
	shr	eax, 2
	push	eax
	push	2021161080				; 78787878H
	push	esi
	call	_stosd

; 57   : 
; 58   :     com1_recv = (CPipeAsync*)&base[0*KB];
; 59   :     Pipe->CreateAsync(com1_recv, nullptr, SerialPutb);

	mov	eax, DWORD PTR _Pipe
	mov	ebx, OFFSET _SerialPutb
	push	ebx
	push	0
	push	esi
	mov	DWORD PTR _com1_recv, esi
	call	DWORD PTR [eax+4]

; 60   :     com1_recv->Writer = (void*)SerialPutb;

	mov	eax, DWORD PTR _com1_recv

; 61   :     com1_recv->Lock = COM1;
; 62   : 
; 63   :     com1_send = (CPipeAsync*)&base[4*KB];
; 64   :     Pipe->CreateAsync(com1_send, SerialPutb, nullptr);

	push	0
	push	ebx
	mov	DWORD PTR [eax+20], ebx
	mov	DWORD PTR [eax+4], 1016			; 000003f8H
	lea	eax, DWORD PTR [esi+4096]
	mov	DWORD PTR _com1_send, eax
	push	eax
	mov	eax, DWORD PTR _Pipe
	call	DWORD PTR [eax+4]

; 65   :     com1_send->Reader = (void*)SerialPutb;

	mov	eax, DWORD PTR _com1_send
	add	esp, 36					; 00000024H
	mov	DWORD PTR [eax+16], ebx

; 66   :     com1_send->Lock = COM1;

	mov	DWORD PTR [eax+4], 1016			; 000003f8H

; 67   :     return true;

	xor	eax, eax
	pop	esi
	inc	eax
	pop	ebx

; 68   : }

	ret	0
_InstallCom1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_base$ = 8						; size = 4
_size$ = 12						; size = 4
_EnableSerial PROC

; 86   :     if (!EnableCom(COM1)) return false;

	mov	ecx, 1016				; 000003f8H
	call	_EnableCom
	test	eax, eax
	jne	SHORT $LN2@EnableSeri
$LN5@EnableSeri:
	xor	eax, eax

; 91   : }

	ret	0
$LN2@EnableSeri:

; 87   :     if (!EnableCom(COM2)) return false;

	mov	ecx, 760				; 000002f8H
	call	_EnableCom
	test	eax, eax
	je	SHORT $LN5@EnableSeri

; 88   :     Device->Latch(IRQ_COM2, SerialCom2);

	mov	eax, DWORD PTR _Device
	push	OFFSET _SerialCom2
	push	35					; 00000023H
	call	DWORD PTR [eax]

; 89   :     Device->Latch(IRQ_COM1, SerialCom1);

	mov	eax, DWORD PTR _Device
	push	OFFSET _SerialCom1
	push	36					; 00000024H
	call	DWORD PTR [eax]

; 90   :     return true;

	xor	eax, eax
	add	esp, 16					; 00000010H
	inc	eax

; 91   : }

	ret	0
_EnableSerial ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_pipe$ = 8						; size = 4
_c$1$ = 11						; size = 1
_SerialPutb PROC

; 12   : bool SerialPutb(CPipeAsync *pipe) {

	push	ebp
	mov	ebp, esp
	push	esi

; 13   :     int port = pipe->Lock;

	mov	esi, DWORD PTR _pipe$[ebp]
	push	edi

; 14   :     while (pipe->Head != pipe->Tail) {

	mov	eax, DWORD PTR [esi+24]
	mov	edi, DWORD PTR [esi+4]
	cmp	eax, DWORD PTR [esi+28]
	je	SHORT $LN5@SerialPutb
	push	ebx
	lea	ebx, DWORD PTR [edi+5]
$LL6@SerialPutb:

; 15   :         if (pipe->Consumed == 0) pipe->Tail++;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	jne	SHORT $LN4@SerialPutb
	inc	DWORD PTR [esi+28]
	jmp	SHORT $LN3@SerialPutb
$LN4@SerialPutb:

; 16   :         else pipe->Consumed--;

	dec	eax
	mov	DWORD PTR [esi+12], eax
$LN3@SerialPutb:

; 17   :         u8 c  = pipe->Pointer[pipe->Head % pipe->Capacity];

	mov	ecx, DWORD PTR [esi+24]
	xor	edx, edx
	mov	eax, ecx
	div	DWORD PTR [esi+8]
	mov	eax, DWORD PTR [esi]
	mov	al, BYTE PTR [edx+eax]
	mov	BYTE PTR _c$1$[ebp], al

; 18   :         pipe->Head++;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi+24], eax
$LL2@SerialPutb:

; 19   : 
; 20   :         while ((inb(port+UART_LSR) & 0x20) == 0); // wait for byte to be sent

	push	ebx
	call	_inb
	pop	ecx
	test	al, 32					; 00000020H
	je	SHORT $LL2@SerialPutb

; 21   : 	    outb(port+UART_TX, c); // send byte to serial port

	movzx	eax, BYTE PTR _c$1$[ebp]
	push	eax
	push	edi
	call	_outb
	mov	eax, DWORD PTR [esi+24]
	pop	ecx
	pop	ecx
	cmp	eax, DWORD PTR [esi+28]
	jne	SHORT $LL6@SerialPutb
	pop	ebx
$LN5@SerialPutb:

; 22   :     }
; 23   :     return true;

	xor	eax, eax
	pop	edi
	inc	eax
	pop	esi

; 24   : }

	pop	ebp
	ret	0
_SerialPutb ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_byte$1 = -1						; size = 1
_Serial	PROC
; _esp$ = ecx
; _pipe$ = edx

; 26   : u32 Serial(u32 esp, CPipeAsync *pipe) {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, edx
	mov	ebx, ecx
	push	edi

; 27   :     int port = pipe->Lock;

	mov	edi, DWORD PTR [esi+4]

; 28   : 	char c = inb(port+UART_LSR); // check to see if char has been received

	lea	eax, DWORD PTR [edi+5]
	push	eax
	call	_inb
	pop	ecx

; 29   : 	if (c & 1) {

	test	al, 1
	je	SHORT $LN1@Serial

; 30   :         char byte = inb(port+UART_TX);

	push	edi
	call	_inb
	mov	BYTE PTR _byte$1[ebp], al

; 31   :         Pipe->WriteAsync(pipe, &byte, 1);

	lea	eax, DWORD PTR _byte$1[ebp]
	push	1
	push	eax
	mov	eax, DWORD PTR _Pipe
	push	esi
	call	DWORD PTR [eax+32]
	add	esp, 16					; 00000010H
$LN1@Serial:

; 32   :     }
; 33   :     return esp;

	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 34   : }

	mov	esp, ebp
	pop	ebp
	ret	0
_Serial	ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_err$ = 8						; size = 4
_esp$ = 12						; size = 4
_SerialCom1 PROC

; 37   :     return Serial(esp, com1_recv);

	mov	edx, DWORD PTR _com1_recv
	mov	ecx, DWORD PTR _esp$[esp-4]
	jmp	_Serial
_SerialCom1 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_err$ = 8						; size = 4
_esp$ = 12						; size = 4
_SerialCom2 PROC

; 41   :     return Serial(esp, com2_recv);

	mov	edx, DWORD PTR _com2_recv
	mov	ecx, DWORD PTR _esp$[esp-4]
	jmp	_Serial
_SerialCom2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\drivers\serial.c
_TEXT	SEGMENT
_EnableCom PROC
; _port$ = ecx

; 44   : bool EnableCom(u32 port) {

	push	ebx
	push	esi
	mov	ebx, ecx
	push	edi

; 45   : 	outb(port+UART_IE, UART_IE_RC); // Enable Recieve Data Interrupt

	push	1
	lea	edi, DWORD PTR [ebx+1]
	push	edi
	call	_outb

; 46   : 	outb(port+UART_LCR, 0x80); // SET DLAB ON

	lea	esi, DWORD PTR [ebx+3]
	push	128					; 00000080H
	push	esi
	call	_outb

; 47   : 	outb(port+UART_DLL, 0x0C); // Set Baud rate - Divisor Latch Low Byte

	push	12					; 0000000cH
	push	ebx
	call	_outb

; 48   : 	outb(port+UART_DLH, 0x00); // Set Baud rate - Divisor Latch High Byte

	push	0
	push	edi
	call	_outb

; 49   : 	outb(port+UART_LCR, 0x03); // 8 Bits, No Parity, 1 Stop Bit

	push	3
	push	esi
	call	_outb

; 50   : 	outb(port+UART_FCR, 0xC7); // FIFO Control Register

	lea	ecx, DWORD PTR [ebx+2]
	push	199					; 000000c7H
	push	ecx
	call	_outb

; 51   : 	outb(port+UART_MCR, 0x0B); // Turn on DTR, RTS, and OUT2

	lea	ecx, DWORD PTR [ebx+4]
	push	11					; 0000000bH
	push	ecx
	call	_outb
	add	esp, 56					; 00000038H

; 52   :     return true;

	xor	eax, eax
	inc	eax
	pop	edi
	pop	esi
	pop	ebx

; 53   : }

	ret	0
_EnableCom ENDP
_TEXT	ENDS
END
