; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\FYP\develop\spartan\source\Kernel\Device\Device.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Device
_device	DD	FLAT:_IDevice_Latch
	DD	FLAT:_IDevice_Unlatch
	DD	FLAT:_IDevice_Hook
	DD	FLAT:_IDevice_Unhook
_Device	DD	FLAT:_device
PUBLIC	_IDevice_Unhook
PUBLIC	_IDevice_Hook
PUBLIC	_IDevice_Unlatch
PUBLIC	_IDevice_Latch
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\device.c
_TEXT	SEGMENT
_irq$ = 8						; size = 4
_handler$ = 12						; size = 4
_IDevice_Latch PROC

; 8    :     //Logger("IDevice_Hook(%X, %X)\n", irq, handler);
; 9    :     u32 *list = (u32*)Monitor->GetBase('IRQ ');

	mov	eax, DWORD PTR _Monitor
	push	esi
	push	edi
	mov	edi, 1230131488				; 49525120H
	push	edi
	call	DWORD PTR [eax+24]

; 10   :     if (list) {

	mov	esi, DWORD PTR _irq$[esp+8]
	pop	ecx
	test	eax, eax
	je	SHORT $LN1@IDevice_La

; 11   :         list[irq] = (u32)handler;

	mov	ecx, DWORD PTR _handler$[esp+4]
	mov	DWORD PTR [eax+esi*4], ecx

; 12   :         Monitor->Protect('IRQ ');

	mov	ecx, DWORD PTR _Monitor
	push	edi
	call	DWORD PTR [ecx+20]
	pop	ecx
$LN1@IDevice_La:

; 13   :     }
; 14   :     return irq;

	pop	edi
	mov	eax, esi
	pop	esi

; 15   : }

	ret	0
_IDevice_Latch ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\device.c
_TEXT	SEGMENT
_irq$ = 8						; size = 4
_IDevice_Unlatch PROC

; 18   :     u32 *list = (u32*)Monitor->GetBase('IRQ ');

	mov	eax, DWORD PTR _Monitor
	push	esi
	push	edi
	mov	edi, 1230131488				; 49525120H
	push	edi
	call	DWORD PTR [eax+24]

; 19   :     if (list) {

	mov	esi, DWORD PTR _irq$[esp+8]
	pop	ecx
	test	eax, eax
	je	SHORT $LN1@IDevice_Un

; 20   :         list[irq] = (u32)DefaultIsrStub;

	mov	DWORD PTR [eax+esi*4], OFFSET _DefaultIsrStub

; 21   :         Monitor->Protect('IRQ ');

	mov	ecx, DWORD PTR _Monitor
	push	edi
	call	DWORD PTR [ecx+20]
	pop	ecx
$LN1@IDevice_Un:

; 22   :     }
; 23   :     return irq;

	pop	edi
	mov	eax, esi
	pop	esi

; 24   : }

	ret	0
_IDevice_Unlatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\device.c
_TEXT	SEGMENT
_device$ = 8						; size = 4
_EndPoint$ = 12						; size = 4
_IDevice_Hook PROC

; 27   :     CPipe *pipe = (CPipe*)Monitor->GetBase(device);

	mov	eax, DWORD PTR _Monitor
	push	DWORD PTR _device$[esp-4]
	call	DWORD PTR [eax+24]
	pop	ecx
	mov	ecx, eax

; 28   :     if (!pipe) return false;

	test	ecx, ecx
	jne	SHORT $LN1@IDevice_Ho

; 31   : }

	ret	0
$LN1@IDevice_Ho:

; 29   :     pipe->Reader = (u32)EndPoint;

	mov	eax, DWORD PTR _EndPoint$[esp-4]
	mov	DWORD PTR [ecx+16], eax

; 30   :     return true;

	xor	eax, eax
	inc	eax

; 31   : }

	ret	0
_IDevice_Hook ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\device\device.c
_TEXT	SEGMENT
_device$ = 8						; size = 4
_IDevice_Unhook PROC

; 34   :     CPipe *pipe = (CPipe*)Monitor->GetBase(device);

	mov	eax, DWORD PTR _Monitor
	push	DWORD PTR _device$[esp-4]
	call	DWORD PTR [eax+24]
	pop	ecx

; 35   :     if (!pipe) return false;

	test	eax, eax
	jne	SHORT $LN1@IDevice_Un

; 38   : }

	ret	0
$LN1@IDevice_Un:

; 36   :     pipe->Reader = nullptr;

	and	DWORD PTR [eax+16], 0

; 37   :     return true;

	xor	eax, eax
	inc	eax

; 38   : }

	ret	0
_IDevice_Unhook ENDP
_TEXT	ENDS
END
