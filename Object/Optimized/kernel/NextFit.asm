; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\FYP\develop\spartan\Source\Kernel\Memory\Heap\NextFit.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_Memory
PUBLIC	_SysMem
PUBLIC	_Ring3Heap
PUBLIC	_Ring0Heap
_Memory	DD	FLAT:_Ring3Heap
_SysMem	DD	FLAT:_Ring0Heap
_Ring3Heap DD	FLAT:_IMemory_Ring3Alloc
	DD	FLAT:_IMemory_Ring3Free
_Ring0Heap DD	FLAT:_IMemory_Ring0Alloc
	DD	FLAT:_IMemory_Ring0Free
PUBLIC	_IMemory_Ring3Free
PUBLIC	_IMemory_Ring3Alloc
PUBLIC	_IMemory_Ring0Free
PUBLIC	_IMemory_Ring0Alloc
PUBLIC	_INextFit_Free
PUBLIC	_INextFit_Alloc
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\heap\nextfit.c
_TEXT	SEGMENT
_INextFit_Alloc PROC
; _heap$ = ecx
; _len$ = edx

; 6    : void *INextFit_Alloc(CPool *heap, int len) {

	push	ebx
	push	ebp
	push	esi
	push	edi
	mov	edi, ecx

; 7    :     if (!heap || len <= 0) return nullptr;

	test	edi, edi
	je	SHORT $LN12@INextFit_A
	test	edx, edx
	jle	SHORT $LN12@INextFit_A

; 8    :     len = ((len + heap->Gran-1) & ~(heap->Gran-1)) / heap->Gran;

	mov	esi, DWORD PTR [edi+16]
	lea	eax, DWORD PTR [edx-1]
	add	eax, esi
	lea	ecx, DWORD PTR [esi-1]
	not	ecx
	and	eax, ecx
	cdq
	idiv	esi

; 9    :     for (int buf = heap->Next; buf + len != heap->Next; buf = ++buf % heap->Count) {

	mov	esi, DWORD PTR [edi+24]
	mov	ebp, eax
	lea	ecx, DWORD PTR [esi+ebp]
	cmp	ecx, esi
	je	SHORT $LN12@INextFit_A

; 10   :         if (buf + len >= heap->Count) {

	mov	ebx, DWORD PTR [edi+20]
$LL11@INextFit_A:
	cmp	ecx, ebx
	jl	SHORT $LN8@INextFit_A

; 11   :             buf = heap->Count - 1;

	lea	esi, DWORD PTR [ebx-1]

; 12   :             continue;

	jmp	SHORT $LN10@INextFit_A
$LN8@INextFit_A:

; 13   :         }
; 14   :         for (int n = 0; heap->Node[buf + n] == 'o'; n++) {

	mov	eax, DWORD PTR [edi+8]
	xor	ecx, ecx
	add	eax, esi
	cmp	BYTE PTR [eax], 111			; 0000006fH
	jne	SHORT $LN10@INextFit_A
	lea	edx, DWORD PTR [ebp-1]
$LL7@INextFit_A:

; 15   :             if (n < len-1) continue;

	cmp	ecx, edx
	jge	SHORT $LN4@INextFit_A

; 13   :         }
; 14   :         for (int n = 0; heap->Node[buf + n] == 'o'; n++) {

	inc	ecx
	inc	eax
	cmp	BYTE PTR [eax], 111			; 0000006fH
	je	SHORT $LL7@INextFit_A
$LN10@INextFit_A:

; 9    :     for (int buf = heap->Next; buf + len != heap->Next; buf = ++buf % heap->Count) {

	lea	eax, DWORD PTR [esi+1]
	cdq
	idiv	ebx
	mov	esi, edx
	lea	ecx, DWORD PTR [esi+ebp]
	cmp	ecx, DWORD PTR [edi+24]
	jne	SHORT $LL11@INextFit_A
$LN12@INextFit_A:

; 7    :     if (!heap || len <= 0) return nullptr;

	xor	eax, eax
$LN14@INextFit_A:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 19   :         }
; 20   :     }
; 21   :     return nullptr;
; 22   : }

	ret	0
$LN4@INextFit_A:

; 16   :             heap->Next = (buf + len) % heap->Count;

	lea	eax, DWORD PTR [esi+ebp]
	cdq
	idiv	ebx

; 17   :             for (heap->Node[buf] = 'X'; n > 0; heap->Node[buf+n--] = 'x');

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [edi+24], edx
	mov	BYTE PTR [esi+eax], 88			; 00000058H
	jmp	SHORT $LN29@INextFit_A
$LL3@INextFit_A:
	mov	eax, DWORD PTR [edi+8]
	add	eax, ecx
	dec	ecx
	mov	BYTE PTR [eax+esi], 120			; 00000078H
$LN29@INextFit_A:
	test	ecx, ecx
	jg	SHORT $LL3@INextFit_A

; 18   :             return &heap->Data[buf*heap->Gran];

	mov	eax, DWORD PTR [edi+16]
	imul	eax, esi
	add	eax, DWORD PTR [edi+12]
	jmp	SHORT $LN14@INextFit_A
_INextFit_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\heap\nextfit.c
_TEXT	SEGMENT
_INextFit_Free PROC
; _heap$ = ecx
; _buf$ = edx

; 25   :     if (!heap || !buf) return false;

	test	ecx, ecx
	je	SHORT $LN10@INextFit_F
	test	edx, edx
	je	SHORT $LN10@INextFit_F

; 26   :     int p = (int)((u32)buf / heap->Gran);

	mov	eax, edx
	xor	edx, edx
	div	DWORD PTR [ecx+16]

; 27   :     if (p >= heap->Count) return false;

	cmp	eax, DWORD PTR [ecx+20]
	jge	SHORT $LN10@INextFit_F

; 28   :     if (heap->Node[p] != 'X') return false;

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+eax], 88			; 00000058H
	je	SHORT $LN25@INextFit_F
$LN10@INextFit_F:

; 25   :     if (!heap || !buf) return false;

	xor	eax, eax

; 37   : }

	ret	0
$LL7@INextFit_F:

; 29   :     for (heap->Node[p++] = 'o'; p < heap->Count; p++) {
; 30   :         if (heap->Node[p] == 'x') heap->Node[p] = 'o';

	mov	edx, DWORD PTR [ecx+8]
	cmp	BYTE PTR [edx+eax], 120			; 00000078H
	jne	SHORT $LN4@INextFit_F
$LN25@INextFit_F:
	mov	BYTE PTR [edx+eax], 111			; 0000006fH
	inc	eax
	cmp	eax, DWORD PTR [ecx+20]
	jl	SHORT $LL7@INextFit_F
$LN4@INextFit_F:

; 31   :         else break;
; 32   :     }
; 33   :     while (heap->Next > 0 && heap->Node[heap->Next-1] == 'o') {

	cmp	DWORD PTR [ecx+24], 0
	jle	SHORT $LN1@INextFit_F
	mov	edx, DWORD PTR [ecx+8]
$LL2@INextFit_F:
	mov	eax, DWORD PTR [ecx+24]
	cmp	BYTE PTR [eax+edx-1], 111		; 0000006fH
	jne	SHORT $LN1@INextFit_F

; 34   :         heap->Next--;

	dec	eax
	mov	DWORD PTR [ecx+24], eax
	test	eax, eax
	jg	SHORT $LL2@INextFit_F
$LN1@INextFit_F:

; 35   :     }
; 36   :     return true;

	xor	eax, eax
	inc	eax

; 37   : }

	ret	0
_INextFit_Free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\heap\nextfit.c
_TEXT	SEGMENT
_len$ = 8						; size = 4
_IMemory_Ring0Alloc PROC

; 40   :     CPool *Heap = (CPool*)MMAP_HEAPPOOL;
; 41   :     return INextFit_Alloc(Heap, len);

	mov	edx, DWORD PTR _len$[esp-4]
	mov	ecx, 1536				; 00000600H
	jmp	_INextFit_Alloc
_IMemory_Ring0Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\heap\nextfit.c
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_IMemory_Ring0Free PROC

; 45   :     CPool *Heap = (CPool*)MMAP_HEAPPOOL;
; 46   :     return INextFit_Free(Heap, buf);

	mov	edx, DWORD PTR _buf$[esp-4]
	mov	ecx, 1536				; 00000600H
	jmp	_INextFit_Free
_IMemory_Ring0Free ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\heap\nextfit.c
_TEXT	SEGMENT
_len$ = 8						; size = 4
_IMemory_Ring3Alloc PROC

; 50   :     CPeb *peb = Process->GetPeb();

	mov	eax, DWORD PTR _Process
	call	DWORD PTR [eax+24]

; 51   :     if (!peb) return 0;

	test	eax, eax
	jne	SHORT $LN1@IMemory_Ri

; 53   : }

	ret	0
$LN1@IMemory_Ri:

; 52   :     return INextFit_Alloc(peb->HeapPool, len);

	mov	edx, DWORD PTR _len$[esp-4]
	mov	ecx, DWORD PTR [eax]
	jmp	_INextFit_Alloc
_IMemory_Ring3Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\fyp\develop\spartan\source\kernel\memory\heap\nextfit.c
_TEXT	SEGMENT
_buf$ = 8						; size = 4
_IMemory_Ring3Free PROC

; 56   :     CPeb *peb = Process->GetPeb();

	mov	eax, DWORD PTR _Process
	call	DWORD PTR [eax+24]

; 57   :     if (!peb) return 0;

	test	eax, eax
	jne	SHORT $LN1@IMemory_Ri

; 59   : }

	ret	0
$LN1@IMemory_Ri:

; 58   :     return INextFit_Free(peb->HeapPool, buf);

	mov	edx, DWORD PTR _buf$[esp-4]
	mov	ecx, DWORD PTR [eax]
	jmp	_INextFit_Free
_IMemory_Ring3Free ENDP
_TEXT	ENDS
END
