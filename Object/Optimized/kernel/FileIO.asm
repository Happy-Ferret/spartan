; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.40629.0 

	TITLE	C:\Users\cex123\Desktop\XXXXX\osdev\osdev-216\Source\Kernel\Device\FileIO\FileIO.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_FileIO
PUBLIC	_fileio
EXTRN	__imp__BinarySearchPartial:PROC
EXTRN	__imp__MemCmp:PROC
_FileIO	DD	FLAT:_fileio
_fileio	DD	00H
	DD	FLAT:_IFileIO_FindFirst
	DD	FLAT:_IFileIO_FindNext
	DD	FLAT:_IFileIO_Open
	DD	FLAT:_IFileIO_Close
	DD	FLAT:_IFileIO_Read
	DD	FLAT:_IFileIO_Write
	DD	FLAT:_IFileIO_Size
	DD	FLAT:_IFileIO_Seek
	DD	FLAT:_IFileIO_Base
PUBLIC	_IFileIO_FindNext
PUBLIC	_IFileIO_FindFirst
PUBLIC	_IFileIO_Open
PUBLIC	_IFileIO_Base
PUBLIC	_IFileIO_Seek
PUBLIC	_IFileIO_Size
PUBLIC	_IFileIO_Write
PUBLIC	_IFileIO_Read
PUBLIC	_IFileIO_Close
PUBLIC	_IFileIO_Release
PUBLIC	_IFileIO_Alloc
PUBLIC	_EnableRamDisk
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_EnableRamDisk PROC
; _base$ = ecx
; _size$dead$ = edx

; 29   :     if (!base) return 0;

	test	ecx, ecx
	jne	SHORT $LN1@EnableRamD
	xor	eax, eax

; 33   : }

	ret	0
$LN1@EnableRamD:

; 30   :     fileio.Disk = (CDisk*)&base[4*KB];

	lea	eax, DWORD PTR [ecx+4096]
	mov	DWORD PTR _fileio, eax

; 31   :     fileio.Disk->DiskBase = 0;

	and	DWORD PTR [eax+32], 0

; 32   :     return 1;

	xor	eax, eax
	inc	eax

; 33   : }

	ret	0
_EnableRamDisk ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_IFileIO_Alloc PROC
; _disk$ = ecx

; 36   :     if (!disk) return 0;

	test	ecx, ecx
	jne	SHORT $LN8@IFileIO_Al
	xor	eax, eax

; 54   : }

	ret	0
$LN8@IFileIO_Al:

; 37   : 
; 38   :     char *block = (char*)disk;
; 39   :     block = &block[disk->Geometry];

	mov	edx, DWORD PTR [ecx+44]
	push	ebx
	push	esi

; 40   :     int blocks = disk->Capacity;
; 41   : 
; 42   :     for (int i = disk->NextFile-1; i != disk->NextFile; i--) {

	mov	esi, DWORD PTR [ecx+72]
	add	edx, ecx
	lea	eax, DWORD PTR [esi-1]
	jmp	SHORT $LN19@IFileIO_Al
$LL7@IFileIO_Al:

; 43   :         if (i < 64 || block[i] == 'x') {

	cmp	eax, 64					; 00000040H
	jl	SHORT $LN3@IFileIO_Al
	mov	bl, BYTE PTR [eax+edx]
	cmp	bl, 120					; 00000078H
	je	SHORT $LN3@IFileIO_Al

; 45   : 
; 46   :         } else if (block[i] == 'o') {

	cmp	bl, 111					; 0000006fH
	jne	SHORT $LN6@IFileIO_Al

; 47   :             block[i] = 'f';

	mov	BYTE PTR [eax+edx], 102			; 00000066H

; 48   :             disk->NextFile = i;
; 49   :             disk->FileCount++;

	inc	DWORD PTR [ecx+60]
	mov	DWORD PTR [ecx+72], eax

; 50   :             return i;

	jmp	SHORT $LN17@IFileIO_Al
$LN3@IFileIO_Al:

; 44   :             i = blocks;

	mov	eax, DWORD PTR [ecx+40]
$LN6@IFileIO_Al:

; 40   :     int blocks = disk->Capacity;
; 41   : 
; 42   :     for (int i = disk->NextFile-1; i != disk->NextFile; i--) {

	dec	eax
$LN19@IFileIO_Al:
	cmp	eax, esi
	jne	SHORT $LL7@IFileIO_Al

; 51   :         }
; 52   :     }
; 53   :     return 0;

	xor	eax, eax
$LN17@IFileIO_Al:
	pop	esi
	pop	ebx

; 54   : }

	ret	0
_IFileIO_Alloc ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_IFileIO_Release PROC
; _disk$ = ecx
; _sector$ = edx

; 56   : int IFileIO_Release(CDisk *disk, int sector) {

	push	esi

; 57   :     if (!disk) return 0;

	test	ecx, ecx
	je	SHORT $LN6@IFileIO_Re

; 58   :     if (sector < 64 || sector > disk->Capacity) return 0;

	cmp	edx, 64					; 00000040H
	jl	SHORT $LN6@IFileIO_Re
	cmp	edx, DWORD PTR [ecx+40]
	jg	SHORT $LN6@IFileIO_Re

; 59   : 
; 60   :     char *block = (char*)disk;
; 61   :     block = &block[disk->Geometry];

	mov	esi, DWORD PTR [ecx+44]
	add	esi, ecx

; 62   :     int blocks = disk->Capacity;
; 63   : 
; 64   :     if (block[sector] != 'f') return 0;

	cmp	BYTE PTR [esi+edx], 102			; 00000066H
	jne	SHORT $LN6@IFileIO_Re

; 65   :     block[sector] = 'o';

	mov	BYTE PTR [esi+edx], 111			; 0000006fH

; 66   :     disk->FileCount--;
; 67   :     while (block[disk->NextFile] == 'o') {

	mov	eax, DWORD PTR [ecx+72]
	dec	DWORD PTR [ecx+60]
	cmp	BYTE PTR [esi+eax], 111			; 0000006fH
	jne	SHORT $LN16@IFileIO_Re
$LL4@IFileIO_Re:

; 68   :         if (disk->NextFile < 64 || disk->NextFile == disk->Capacity) break;

	mov	eax, DWORD PTR [ecx+72]
	cmp	eax, 64					; 00000040H
	jl	SHORT $LN16@IFileIO_Re
	cmp	eax, DWORD PTR [ecx+40]
	je	SHORT $LN16@IFileIO_Re

; 69   :         disk->NextFile++;

	inc	eax
	mov	DWORD PTR [ecx+72], eax
	cmp	BYTE PTR [eax+esi], 111			; 0000006fH
	je	SHORT $LL4@IFileIO_Re
$LN16@IFileIO_Re:

; 70   :     }
; 71   :     return 1;

	xor	eax, eax
	inc	eax
	pop	esi

; 72   : }

	ret	0
$LN6@IFileIO_Re:

; 58   :     if (sector < 64 || sector > disk->Capacity) return 0;

	xor	eax, eax
	pop	esi

; 72   : }

	ret	0
_IFileIO_Release ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_file$ = 8						; size = 4
_IFileIO_Close PROC

; 75   :     if (!file) return 0;

	cmp	DWORD PTR _file$[esp-4], 0
	jne	SHORT $LN2@IFileIO_Cl
$LN5@IFileIO_Cl:
	xor	eax, eax

; 80   : }

	ret	0
$LN2@IFileIO_Cl:

; 76   :     int sector = ((int)file - (int)fileio.Disk) / (4*KB);

	mov	eax, DWORD PTR _file$[esp-4]
	mov	ecx, DWORD PTR _fileio
	sub	eax, ecx
	cdq
	and	edx, 4095				; 00000fffH
	add	edx, eax
	sar	edx, 12					; 0000000cH

; 77   :     if (!IFileIO_Release(fileio.Disk, sector)) return 0;

	call	_IFileIO_Release
	test	eax, eax
	je	SHORT $LN5@IFileIO_Cl

; 78   :     stosd(file, 'xxxx', 4*KB/4);

	push	1024					; 00000400H
	push	2021161080				; 78787878H
	push	DWORD PTR _file$[esp+4]
	call	_stosd

; 79   :     return 1;

	xor	eax, eax
	add	esp, 12					; 0000000cH
	inc	eax

; 80   : }

	ret	0
_IFileIO_Close ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IFileIO_Read PROC

; 82   : int IFileIO_Read(CFile *file, char *buf, int len) {

	push	esi

; 83   :     if (!file) return 0;

	mov	esi, DWORD PTR _file$[esp]
	test	esi, esi
	jne	SHORT $LN6@IFileIO_Re
	xor	eax, eax
	pop	esi

; 94   : }

	ret	0
$LN6@IFileIO_Re:
	push	edi

; 84   :     INode *node = file->Node;
; 85   :     if (!node) return 0;

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jne	SHORT $LN5@IFileIO_Re
	xor	eax, eax
	jmp	SHORT $LN14@IFileIO_Re
$LN5@IFileIO_Re:
	push	ebx

; 86   : 
; 87   :     char *data = fileio.Base(file);

	push	esi
	call	DWORD PTR _fileio+36

; 88   :     int size = fileio.Size(file);

	push	esi
	mov	ebx, eax
	call	DWORD PTR _fileio+28
	mov	edx, eax
	pop	ecx
	pop	ecx

; 89   :     for (int i = 0; i < len; i++) {

	cmp	DWORD PTR _len$[esp+8], edi
	jle	SHORT $LN2@IFileIO_Re
	mov	ecx, DWORD PTR _buf$[esp+8]
$LL4@IFileIO_Re:

; 90   :         if (file->Head >= size) return i;

	mov	eax, DWORD PTR [esi]
	cmp	eax, edx
	jge	SHORT $LN10@IFileIO_Re

; 91   :         buf[i] = data[file->Head++];

	mov	al, BYTE PTR [eax+ebx]
	mov	BYTE PTR [edi+ecx], al
	inc	DWORD PTR [esi]
	inc	edi
	cmp	edi, DWORD PTR _len$[esp+8]
	jl	SHORT $LL4@IFileIO_Re
$LN2@IFileIO_Re:

; 92   :     }
; 93   :     return 0;

	xor	eax, eax
$LN15@IFileIO_Re:
	pop	ebx
$LN14@IFileIO_Re:
	pop	edi
	pop	esi

; 94   : }

	ret	0
$LN10@IFileIO_Re:

; 90   :         if (file->Head >= size) return i;

	mov	eax, edi
	jmp	SHORT $LN15@IFileIO_Re
_IFileIO_Read ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_IFileIO_Write PROC

; 96   : int IFileIO_Write(CFile *file, char *buf, int len) {

	push	esi

; 97   :     if (!file) return 0;

	mov	esi, DWORD PTR _file$[esp]
	test	esi, esi
	jne	SHORT $LN6@IFileIO_Wr
	xor	eax, eax
	pop	esi

; 108  : }

	ret	0
$LN6@IFileIO_Wr:
	push	edi

; 98   :     INode *node = file->Node;
; 99   :     if (!node) return 0;

	xor	edi, edi
	cmp	DWORD PTR [esi+12], edi
	jne	SHORT $LN5@IFileIO_Wr
	xor	eax, eax
	jmp	SHORT $LN14@IFileIO_Wr
$LN5@IFileIO_Wr:
	push	ebx
	push	ebp

; 100  : 
; 101  :     char *data = fileio.Base(file);

	push	esi
	call	DWORD PTR _fileio+36

; 102  :     int size = fileio.Size(file);

	push	esi
	mov	ebp, eax
	call	DWORD PTR _fileio+28
	mov	ebx, eax
	pop	ecx
	pop	ecx

; 103  :     for (int i = 0; i < len; i++) {

	cmp	DWORD PTR _len$[esp+12], edi
	jle	SHORT $LN2@IFileIO_Wr
	mov	edx, DWORD PTR _buf$[esp+12]
$LL4@IFileIO_Wr:

; 104  :         if (file->Head >= size) return i;

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, ebx
	jge	SHORT $LN10@IFileIO_Wr

; 105  :         data[file->Head++] = buf[i];

	mov	al, BYTE PTR [edi+edx]
	mov	BYTE PTR [ecx+ebp], al
	inc	DWORD PTR [esi]
	inc	edi
	cmp	edi, DWORD PTR _len$[esp+12]
	jl	SHORT $LL4@IFileIO_Wr
$LN2@IFileIO_Wr:

; 106  :     }
; 107  :     return 0;

	xor	eax, eax
$LN15@IFileIO_Wr:
	pop	ebp
	pop	ebx
$LN14@IFileIO_Wr:
	pop	edi
	pop	esi

; 108  : }

	ret	0
$LN10@IFileIO_Wr:

; 104  :         if (file->Head >= size) return i;

	mov	eax, edi
	jmp	SHORT $LN15@IFileIO_Wr
_IFileIO_Write ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_file$ = 8						; size = 4
_IFileIO_Size PROC

; 111  :     if (!file) return 0;

	mov	eax, DWORD PTR _file$[esp-4]
	test	eax, eax
	jne	SHORT $LN2@IFileIO_Si
$LN5@IFileIO_Si:
	xor	eax, eax

; 114  : }

	ret	0
$LN2@IFileIO_Si:

; 112  :     if (!file->Node) return 0;

	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN5@IFileIO_Si

; 113  :     return file->Node->FileSize;

	mov	eax, DWORD PTR [eax+8]

; 114  : }

	ret	0
_IFileIO_Size ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_origin$ = 16						; size = 4
_IFileIO_Seek PROC

; 117  :     if (!file) return 0;

	mov	ecx, DWORD PTR _file$[esp-4]
	test	ecx, ecx
	jne	SHORT $LN7@IFileIO_Se
$LN10@IFileIO_Se:
	xor	eax, eax

; 128  : }

	ret	0
$LN7@IFileIO_Se:

; 118  :     INode *node = file->Node;

	mov	edx, DWORD PTR [ecx+12]

; 119  :     if (!node) return 0;

	test	edx, edx
	je	SHORT $LN10@IFileIO_Se

; 120  :     int size = node->FileSize;
; 121  : 
; 122  :     switch (offset) {

	mov	eax, DWORD PTR _offset$[esp-4]
	sub	eax, 0
	je	SHORT $LN3@IFileIO_Se
	dec	eax
	je	SHORT $LN2@IFileIO_Se
	dec	eax
	jne	SHORT $LN4@IFileIO_Se

; 125  :     case SEEK_END: file->Head = size-offset; break;

	mov	eax, DWORD PTR [edx+8]
	sub	eax, 2
	mov	DWORD PTR [ecx], eax
	jmp	SHORT $LN4@IFileIO_Se
$LN2@IFileIO_Se:

; 124  :     case SEEK_CUR: file->Head += offset;     break;

	inc	DWORD PTR [ecx]
	jmp	SHORT $LN4@IFileIO_Se
$LN3@IFileIO_Se:

; 123  :     case SEEK_SET: file->Head = offset;      break;

	and	DWORD PTR [ecx], 0
$LN4@IFileIO_Se:

; 126  :     }
; 127  :     return 1;

	xor	eax, eax
	inc	eax

; 128  : }

	ret	0
_IFileIO_Seek ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_file$ = 8						; size = 4
_IFileIO_Base PROC

; 131  :     if (!file) return 0;

	mov	eax, DWORD PTR _file$[esp-4]
	test	eax, eax
	jne	SHORT $LN2@IFileIO_Ba
$LN5@IFileIO_Ba:
	xor	eax, eax

; 137  : }

	ret	0
$LN2@IFileIO_Ba:

; 132  :     INode *node = file->Node;

	mov	ecx, DWORD PTR [eax+12]

; 133  :     if (!node) return 0;

	test	ecx, ecx
	je	SHORT $LN5@IFileIO_Ba

; 134  : 
; 135  :     char *base = (char*)fileio.Disk->DiskBase;
; 136  :     return &base[(int)node->FileData];

	mov	eax, DWORD PTR _fileio
	mov	eax, DWORD PTR [eax+32]
	add	eax, DWORD PTR [ecx+4]

; 137  : }

	ret	0
_IFileIO_Base ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_path$ = 8						; size = 4
_flag$ = 12						; size = 4
_IFileIO_Open PROC

; 140  :     INode *item = RamDisk->Search(fileio.Disk, path);

	mov	eax, DWORD PTR _RamDisk
	push	edi
	push	DWORD PTR _path$[esp]
	push	DWORD PTR _fileio
	call	DWORD PTR [eax+12]
	mov	edi, eax
	pop	ecx
	pop	ecx

; 141  :     if (!item) return 0; // Error("FileIO.Open [fail] File not found! %s\n", path);

	test	edi, edi
	jne	SHORT $LN3@IFileIO_Op
	pop	edi

; 161  : }

	ret	0
$LN3@IFileIO_Op:

; 142  : 
; 143  :     int sector = IFileIO_Alloc(fileio.Disk);

	mov	ecx, DWORD PTR _fileio
	push	esi
	call	_IFileIO_Alloc
	mov	esi, eax

; 144  :     if (!sector) return 0; // Error("FileIO.Open [fail] Out of disk space! %s\n", path);

	test	esi, esi
	je	SHORT $LN7@IFileIO_Op

; 145  : 
; 146  :     char *base = (char*)fileio.Disk;
; 147  :     CFile *file = (CFile*)&base[sector*4*KB];

	shl	esi, 12					; 0000000cH
	add	esi, DWORD PTR _fileio

; 148  :     if (!file) return 0; // Error("FileIO.Open [fail] Out of disk space! %s\n", path);

	jne	SHORT $LN1@IFileIO_Op
$LN7@IFileIO_Op:
	xor	eax, eax
	jmp	SHORT $LN6@IFileIO_Op
$LN1@IFileIO_Op:

; 149  : 
; 150  :     stosd(file, 0, 4*KB/4);

	push	1024					; 00000400H
	push	0
	push	esi
	call	_stosd

; 151  :     file->Head  = 0;

	and	DWORD PTR [esi], 0
	add	esp, 12					; 0000000cH

; 152  :     file->Tail  = 0;

	and	DWORD PTR [esi+4], 0

; 153  :     file->Size  = 4*KB - sizeof(CFile);
; 154  :     file->Node  = item;
; 155  : 
; 156  :     file->Open  = (int(*)(char*,char*))IFileIO_Open;
; 157  :     file->Close = (int(*)(CFile*))IFileIO_Close;
; 158  :     file->Read  = (int(*)(CFile*,char*,int))IFileIO_Read;
; 159  :     file->Write = (int(*)(void*,char*,int))IFileIO_Write;
; 160  :     return file;

	mov	eax, esi
	mov	DWORD PTR [esi+8], 4064			; 00000fe0H
	mov	DWORD PTR [esi+12], edi
	mov	DWORD PTR [esi+16], OFFSET _IFileIO_Open
	mov	DWORD PTR [esi+20], OFFSET _IFileIO_Close
	mov	DWORD PTR [esi+24], OFFSET _IFileIO_Read
	mov	DWORD PTR [esi+28], OFFSET _IFileIO_Write
$LN6@IFileIO_Op:

; 161  : }

	pop	esi
	pop	edi
	ret	0
_IFileIO_Open ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_path$ = 8						; size = 4
_IFileIO_FindFirst PROC

; 164  :     CDisk *disk = fileio.Disk;

	mov	ecx, DWORD PTR _fileio

; 165  :     char *base = (char*)disk;
; 166  :     INode *node = (INode*)&base[disk->NodeList];
; 167  : 
; 168  :     if (!path) return node;

	mov	eax, DWORD PTR _path$[esp-4]
	push	esi
	mov	esi, DWORD PTR [ecx+48]
	add	esi, ecx
	test	eax, eax
	jne	SHORT $LN3@IFileIO_Fi
$LN6@IFileIO_Fi:
	mov	eax, esi
	pop	esi

; 173  : }

	ret	0
$LN3@IFileIO_Fi:

; 169  :     if (!path[0]) return node;

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN6@IFileIO_Fi

; 170  :     int n = BinarySearchPartial((char*)node, disk->NodeCount, sizeof(INode), 16, path);

	push	eax
	push	16					; 00000010H
	push	64					; 00000040H
	push	DWORD PTR [ecx+56]
	push	esi
	call	DWORD PTR __imp__BinarySearchPartial
	add	esp, 20					; 00000014H

; 171  :     if (n < 0) return 0;

	test	eax, eax
	jns	SHORT $LN1@IFileIO_Fi
	xor	eax, eax
	pop	esi

; 173  : }

	ret	0
$LN1@IFileIO_Fi:

; 172  :     return &node[n];

	shl	eax, 6
	add	eax, esi
	pop	esi

; 173  : }

	ret	0
_IFileIO_FindFirst ENDP
_TEXT	ENDS
; Function compile flags: /Ogspy
; File c:\users\cex123\desktop\xxxxx\osdev\osdev-216\source\kernel\device\fileio\fileio.c
_TEXT	SEGMENT
_len$1$ = 8						; size = 4
_prev$ = 8						; size = 4
_path$ = 12						; size = 4
_IFileIO_FindNext PROC

; 175  : INode *IFileIO_FindNext(INode *prev, char *path) {

	push	ebx
	push	ebp
	push	esi

; 176  :     if (!prev || !path) return 0;

	mov	esi, DWORD PTR _prev$[esp+8]
	push	edi
	test	esi, esi
	je	SHORT $LN15@IFileIO_Fi
	mov	edi, DWORD PTR _path$[esp+12]
	test	edi, edi
	je	SHORT $LN15@IFileIO_Fi

; 177  : 
; 178  :     CDisk *disk = fileio.Disk;
; 179  :     char *base = (char*)disk;
; 180  :     INode *node = (INode*)&base[disk->NodeList];
; 181  : 
; 182  :     int len = StrLen(path);

	push	edi
	call	DWORD PTR __imp__StrLen
	pop	ecx
	mov	DWORD PTR _len$1$[esp+12], eax

; 183  :     int end = len;
; 184  :     for (int i = len; prev->FileName[i]; i++) {

	mov	ebp, eax
	cmp	BYTE PTR [eax+esi+16], 0
	je	SHORT $LN23@IFileIO_Fi
	mov	cl, BYTE PTR [esi+eax+16]
$LL14@IFileIO_Fi:

; 185  :         if (prev->FileName[i] == '/') {

	cmp	cl, 47					; 0000002fH
	je	SHORT $LN21@IFileIO_Fi

; 183  :     int end = len;
; 184  :     for (int i = len; prev->FileName[i]; i++) {

	mov	cl, BYTE PTR [esi+ebp+17]
	inc	ebp
	test	cl, cl
	jne	SHORT $LL14@IFileIO_Fi

; 194  :             if (MemCmp(skip->FileName, prev->FileName, end) != 0) break;

	jmp	SHORT $LN23@IFileIO_Fi
$LN21@IFileIO_Fi:

; 186  :             end = i;
; 187  :             break;
; 188  :         }
; 189  :     }
; 190  : 
; 191  :     if (end != len) {

	cmp	ebp, eax
	je	SHORT $LN23@IFileIO_Fi

; 192  :         for (INode *skip = &prev[1]; ; skip++) {

	lea	ebx, DWORD PTR [esi+64]

; 193  :             if (skip->FileName[0] == 0) return 0;

	jmp	SHORT $LN32@IFileIO_Fi
$LL9@IFileIO_Fi:

; 194  :             if (MemCmp(skip->FileName, prev->FileName, end) != 0) break;

	push	ebp
	lea	eax, DWORD PTR [esi+16]
	push	eax
	push	ecx
	call	DWORD PTR __imp__MemCmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN30@IFileIO_Fi

; 195  :             prev = skip;

	mov	esi, ebx
	add	ebx, 64					; 00000040H
$LN32@IFileIO_Fi:

; 193  :             if (skip->FileName[0] == 0) return 0;

	lea	ecx, DWORD PTR [ebx+16]
	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LL9@IFileIO_Fi
$LN15@IFileIO_Fi:

; 176  :     if (!prev || !path) return 0;

	xor	eax, eax
$LN17@IFileIO_Fi:
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 204  : }

	ret	0
$LN30@IFileIO_Fi:
	mov	eax, DWORD PTR _len$1$[esp+12]
$LN23@IFileIO_Fi:

; 196  :         }
; 197  :     }
; 198  : 
; 199  :     INode *next = &prev[1];

	add	esi, 64					; 00000040H

; 200  :     if (next->FileName[0] == 0) return 0;

	lea	ecx, DWORD PTR [esi+16]
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN15@IFileIO_Fi

; 201  :     if (!path || !path[0]) return next;

	cmp	BYTE PTR [edi], 0
	je	SHORT $LN2@IFileIO_Fi

; 202  :     if (MemCmp(next->FileName, path, len) == 0) return next;

	push	eax
	push	edi
	push	ecx
	call	DWORD PTR __imp__MemCmp
	add	esp, 12					; 0000000cH
	neg	eax
	sbb	eax, eax
	not	eax
	and	eax, esi

; 203  :     return 0;

	jmp	SHORT $LN17@IFileIO_Fi
$LN2@IFileIO_Fi:

; 201  :     if (!path || !path[0]) return next;

	mov	eax, esi
	jmp	SHORT $LN17@IFileIO_Fi
_IFileIO_FindNext ENDP
_TEXT	ENDS
END
